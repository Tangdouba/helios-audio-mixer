!function(Q,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define("audioMixer",[],B):"object"==typeof exports?exports.audioMixer=B():Q.audioMixer=B()}(window,function(){return function(Q){var B={};function F(t){if(B[t])return B[t].exports;var e=B[t]={i:t,l:!1,exports:{}};return Q[t].call(e.exports,e,e.exports,F),e.l=!0,e.exports}return F.m=Q,F.c=B,F.d=function(Q,B,t){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:t})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var t=Object.create(null);if(F.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var e in Q)F.d(t,e,function(B){return Q[B]}.bind(null,e));return t},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/modules/BaseTrack.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n\n  base Track class, with event and timeline functionality\n\n*/\nvar BaseTrack =\n/*#__PURE__*/\nfunction () {\n  function BaseTrack(params) {\n    _classCallCheck(this, BaseTrack);\n\n    this.id = params.id;\n    this.events = {};\n    this.timelineEvents = params.timelineEvents ? _toConsumableArray(params.timelineEvents) : [];\n  }\n\n  _createClass(BaseTrack, [{\n    key: "destroy",\n    value: function destroy() {}\n    /*\n       Events\n     */\n\n  }, {\n    key: "on",\n    value: function on(eventName, callback) {\n      var track = this;\n\n      if (typeof eventName !== \'string\') {\n        throw new Error(\'Event name must be a string.\');\n      } else if (!callback) {\n        throw new Error(\'Can’t register an event without a callback.\');\n      } else {\n        if (track.events[eventName]) {\n          track.events[eventName].push(callback);\n        } else {\n          track.events[eventName] = [callback];\n        }\n      }\n\n      return track;\n    }\n  }, {\n    key: "off",\n    value: function off(eventName, callback) {\n      var track = this;\n\n      if (callback) {\n        // remove specific callback\n        if (track.events[eventName]) {\n          var index = track.events[eventName].indexOf(callback);\n          track.events[eventName].splice(index, 1);\n        }\n      } else {\n        // remove all callbacks for a given event name\n        if (track.events[eventName]) {\n          track.events[eventName] = [];\n        }\n      }\n\n      return track;\n    }\n  }, {\n    key: "one",\n    value: function one(eventName, callback) {\n      var track = this;\n\n      var wrappedCallback = function wrappedCallback() {\n        track.off(eventName, wrappedCallback);\n        callback();\n      };\n\n      track.on(eventName, wrappedCallback);\n      return track;\n    }\n  }, {\n    key: "trigger",\n    value: function trigger(eventName) {\n      var track = this;\n\n      if (track.events[eventName]) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        track.events[eventName].forEach(function (fn) {\n          return fn.apply(track, args);\n        });\n      }\n\n      return track;\n    }\n    /*\n       Timeline\n         check if any events need to be triggered\n         this is called by the mixer using requestAnimationFrame\n     */\n\n  }, {\n    key: "updateTimelineEvents",\n    value: function updateTimelineEvents(time) {\n      var track = this;\n      var e;\n\n      for (var i = 0; i < track.timelineEvents.length; i++) {\n        e = track.timelineEvents[i];\n\n        if (time >= e.time && !e.triggered) {\n          e.triggered = true;\n          if (e.callback) e.callback.call(track);\n        }\n      }\n    }\n  }]);\n\n  return BaseTrack;\n}();\n\n/* harmony default export */ var modules_BaseTrack = (BaseTrack);\n// CONCATENATED MODULE: ./src/modules/utils.js\nfunction normalize(value) {\n  if (value > 1) return 1;\n  if (value < 0) return 0;\n  return value;\n}\n\nfunction timeFormat(seconds) {\n  var m = Math.floor(seconds / 60) < 10 ? \'0\' + Math.floor(seconds / 60) : Math.floor(seconds / 60);\n  var s = Math.floor(seconds - m * 60) < 10 ? \'0\' + Math.floor(seconds - m * 60) : Math.floor(seconds - m * 60);\n  return m + \':\' + s;\n}\n\nfunction lerp(start, end, now) {\n  return (1 - now) * start + now * end;\n}\n\nfunction timeoutPromise(duration) {\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      return resolve();\n    }, duration);\n  });\n}\n\n/* harmony default export */ var utils = ({\n  normalize: normalize,\n  timeFormat: timeFormat,\n  lerp: lerp,\n  timeoutPromise: timeoutPromise\n});\n// CONCATENATED MODULE: ./src/modules/Html5Track.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction Html5Track_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Html5Track_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Html5Track_createClass(Constructor, protoProps, staticProps) { if (protoProps) Html5Track_defineProperties(Constructor.prototype, protoProps); if (staticProps) Html5Track_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n\n  HTML5 <audio> element track\n\n*/\n\n\n\nvar Html5Track_Html5Track =\n/*#__PURE__*/\nfunction (_BaseTrack) {\n  _inherits(Html5Track, _BaseTrack);\n\n  function Html5Track(params) {\n    var _this;\n\n    Html5Track_classCallCheck(this, Html5Track);\n\n    // call the parent class’s constructor\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Html5Track).call(this, params));\n\n    var track = _assertThisInitialized(_this);\n\n    var defaults = {\n      id: \'\',\n      src: \'\',\n      volume: 1,\n      muted: false,\n      start: 0,\n      loop: false,\n      autoplay: false\n    };\n    track.options = Object.assign(defaults, params); // set up our HTML5 <audio> element\n\n    if (!track.options.src) {\n      throw new Error(\'Can’t create an Html5Track without a src parameter\');\n    }\n\n    track.el = document.createElement(\'audio\');\n    track.el.volume = track.options.volume;\n    track.el.muted = track.options.muted;\n    track.el.loop = track.options.loop;\n    track.el.autoplay = track.options.autoplay;\n    track.el.src = track.options.src;\n    var eventNames = [\'loadstart\', \'loadedmetadata\', \'canplay\', \'canplaythrough\', \'play\', \'pause\', \'ended\', \'timeupdate\', \'seeking\', \'seeked\', \'error\'];\n    eventNames.forEach(function (eventName) {\n      track.el.addEventListener(eventName, _get(_getPrototypeOf(Html5Track.prototype), "trigger", _assertThisInitialized(_this)).bind(track, eventName, false));\n    });\n    return _this;\n  } // ********************************************************\n\n\n  Html5Track_createClass(Html5Track, [{\n    key: "play",\n    value: function play() {\n      this.el.play();\n      return this;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      this.el.pause();\n      return this;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this.el.pause();\n      this.el.currentTime = 0;\n      return this;\n    }\n  }, {\n    key: "currentTime",\n    value: function currentTime(setTo) {\n      var track = this;\n\n      if (typeof setTo === \'number\') {\n        track.el.currentTime = setTo;\n        return track;\n      } else {\n        return track.el.currentTime;\n      }\n    }\n  }, {\n    key: "duration",\n    value: function duration() {\n      var track = this;\n      return track.el.duration;\n    }\n  }, {\n    key: "formattedTime",\n    value: function formattedTime(includeDuration) {\n      var track = this;\n      if (includeDuration) return utils.timeFormat(track.currentTime()) + \'/\' + utils.timeFormat(track.duration());else return utils.timeFormat(track.currentTime());\n    }\n  }, {\n    key: "volume",\n    value: function volume(setTo) {\n      var track = this;\n\n      if (typeof setTo === \'number\') {\n        track.el.volume = utils.normalize(setTo);\n        return track;\n      } else {\n        return track.el.volume;\n      }\n    }\n  }, {\n    key: "tweenVolume",\n    value: function tweenVolume(setTo, duration) {\n      var track = this; // replace existing volume tween\n\n      if (track.volumeTween) {\n        window.cancelAnimationFrame(track.volumeTween);\n      }\n\n      return new Promise(function (resolve, reject) {\n        var fps = 60; // requestAnimationFrame\n\n        var durationInFrames = Math.round(duration * fps);\n        var frameCount = Math.round(duration * fps);\n        var startVolume = track.volume();\n        var endVolume = utils.normalize(setTo);\n        tick();\n\n        function tick() {\n          if (frameCount <= 0) {\n            track.volume(endVolume);\n            resolve(track);\n          } else {\n            track.volumeTween = window.requestAnimationFrame(tick);\n          }\n\n          frameCount -= 1;\n          var progress = 1 - frameCount / durationInFrames;\n          var v = utils.lerp(startVolume, endVolume, progress);\n          track.volume(v);\n        }\n      });\n    }\n  }, {\n    key: "muted",\n    value: function muted(setTo) {\n      var track = this;\n\n      if (typeof setTo === \'boolean\') {\n        track.el.muted = setTo;\n      }\n\n      return track.el.muted;\n    }\n  }, {\n    key: "paused",\n    value: function paused() {\n      var track = this;\n      return track.el.paused;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      var track = this;\n      track.pause();\n    }\n  }]);\n\n  return Html5Track;\n}(modules_BaseTrack);\n\n/* harmony default export */ var modules_Html5Track = (Html5Track_Html5Track);\n// CONCATENATED MODULE: ./src/modules/nodes/GainNode.js\nfunction GainNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GainNode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GainNode_createClass(Constructor, protoProps, staticProps) { if (protoProps) GainNode_defineProperties(Constructor.prototype, protoProps); if (staticProps) GainNode_defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n\n  Gain Node\n\n  let g = new GainNode({\n    context: context,\n    gain:    1,\n  })\n\n  g.node -> the web audio node object\n\n  g.gain(setTo) -> getter/setter\n  g.muted(setTo) -> getter/setter\n\n  g.tweenGain(setTo, duration)\n\n*/\n\n\nvar GainNode_GainNode =\n/*#__PURE__*/\nfunction () {\n  function GainNode(params) {\n    GainNode_classCallCheck(this, GainNode);\n\n    this.ctx = params.context;\n    this.node = this.ctx.createGainNode ? this.ctx.createGainNode() : this.ctx.createGain();\n    this.gain(typeof params.gain === \'number\' ? params.gain : 1);\n  }\n\n  GainNode_createClass(GainNode, [{\n    key: "gain",\n    value: function gain(setTo) {\n      if (typeof setTo === \'number\') {\n        /*\n           \'AudioParam value setter will become equivalent to AudioParam.setValueAtTime() in (Chrome) M65\'\n           Apparently, it\'s bad form to set gain.value directly now, ie\n          \'this.node.gain.value = u.normalize(setTo, 0, 1)\'\n           Recommended behaviour now is to use setTargetAtTime.\n           - https://www.chromestatus.com/features/5287995770929152\n          - https://github.com/mrdoob/three.js/pull/11133\n         */\n        // setTargetAtTime( value, start time (clamped to current time), time constant )\n        this.node.gain.setTargetAtTime(utils.normalize(setTo), this.ctx.currentTime, 0);\n      }\n\n      return this.node.gain.value;\n    } // tweenGain(0, 1, \'linear\')\n\n  }, {\n    key: "tweenGain",\n    value: function tweenGain(setTo, duration) {\n      // using an exponential ramp (not linear) for a more even crossfade\n      // (linear creates a volume dip in the middle)\n      if (typeof this.node.gain.exponentialRampToValueAtTime === \'function\') {\n        setTo = utils.normalize(setTo);\n        if (setTo === 0) setTo = 0.000001; // can\'t use zero for ramps\n\n        this.node.gain.exponentialRampToValueAtTime(setTo, this.ctx.currentTime + duration);\n      }\n    }\n  }, {\n    key: "muted",\n    value: function muted(setTo) {}\n  }]);\n\n  return GainNode;\n}();\n\n/* harmony default export */ var nodes_GainNode = (GainNode_GainNode);\n// CONCATENATED MODULE: ./src/modules/nodes/PannerNode2D.js\nfunction PannerNode2D_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PannerNode2D_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PannerNode2D_createClass(Constructor, protoProps, staticProps) { if (protoProps) PannerNode2D_defineProperties(Constructor.prototype, protoProps); if (staticProps) PannerNode2D_defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n\n  Pan Node (2D - left/right)\n\n*/\nvar PannerNode2D =\n/*#__PURE__*/\nfunction () {\n  function PannerNode2D(params) {\n    PannerNode2D_classCallCheck(this, PannerNode2D);\n\n    var ctx = params.context; // the name of this function is the same for\n    // both prefixed and unprefixed audio contexts\n\n    this.node = ctx.createPanner();\n    this.values = {\n      pan: 0,\n      panX: 0,\n      panY: 0,\n      panZ: 0 // additional setup here\n\n    };\n  }\n\n  PannerNode2D_createClass(PannerNode2D, [{\n    key: "pan",\n    value: function pan(angle) {\n      if (typeof angle === \'string\') {\n        if (angle === \'front\') angle = 0;else if (angle === \'back\') angle = 180;else if (angle === \'left\') angle = 270;else if (angle === \'right\') angle = 90;\n      }\n\n      if (typeof angle === \'number\') {\n        this.values.pan = angle % 360;\n        var angleRad = (-angle + 90) * 0.017453292519943295; // * PI/180\n\n        var x = this.values.panX = Math.cos(angleRad);\n        var y = this.values.panY = Math.sin(angleRad);\n        var z = this.values.panZ = -0.5;\n        this.node.setPosition(x, y, z);\n      }\n\n      return this.values.pan;\n    }\n  }, {\n    key: "tweenPan",\n    value: function tweenPan(angle, duration) {}\n  }]);\n\n  return PannerNode2D;\n}();\n\n/* harmony default export */ var nodes_PannerNode2D = (PannerNode2D);\n// CONCATENATED MODULE: ./src/modules/nodes/PannerNode.js\nfunction PannerNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/*\n\n  Pan Node (3D)\n\n*/\nvar PanNode3D = function PanNode3D(params) {\n  PannerNode_classCallCheck(this, PanNode3D);\n\n  var ctx = params.context; // the name of this function is the same for\n  // both prefixed and unprefixed audio contexts\n\n  this.node = ctx.createPanner(); // additional setup here\n};\n\n/* harmony default export */ var PannerNode = (PanNode3D);\n// CONCATENATED MODULE: ./src/modules/nodes/AnalyserNode.js\nfunction AnalyserNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnalyserNode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnalyserNode_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnalyserNode_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnalyserNode_defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n\n  Analyser Node (FFT)\n\n*/\nvar AnalyserNode =\n/*#__PURE__*/\nfunction () {\n  function AnalyserNode(params) {\n    AnalyserNode_classCallCheck(this, AnalyserNode);\n\n    var ctx = params.context;\n    this.node = ctx.createAnalyser();\n    analyserNode.smoothingTimeConstant = 0.2;\n    analyserNode.fftSize = 32; // create a script processor with bufferSize of 2048\n\n    this.processor = ctx.createScriptProcessor(2048, 1, 1);\n    processorNode.connect(ctx.destination); // processor -> destination\n\n    analyserNode.connect(processorNode); // analyser  -> processor\n\n    this.bufferLength = analyserNode.frequencyBinCount;\n    this.analysis = {\n      raw: new Uint8Array(options.bufferLength),\n      average: 0,\n      low: 0,\n      mid: 0,\n      high: 0\n    };\n  }\n\n  AnalyserNode_createClass(AnalyserNode, [{\n    key: "connect",\n    value: function connect(to) {\n      this.node.connect(to);\n    }\n  }, {\n    key: "get",\n    value: function get() {\n      var third = Math.round(this.bufferLength / 3);\n      var scratch = 0;\n      var i = 0;\n      this.node.getByteFrequencyData(this.analysis.raw); // calculate average, mid, high\n\n      scratch = 0;\n\n      for (i = 0; i < this.bufferLength; i++) {\n        scratch += this.analysis.raw[i];\n      }\n\n      this.analysis.average = scratch / this.bufferLength / 256; // lows\n\n      scratch = 0;\n\n      for (i = 0; i < third; i++) {\n        scratch += this.analysis.raw[i];\n      }\n\n      this.analysis.low = scratch / third / 256; // mids\n\n      scratch = 0;\n\n      for (i = third; i < third * 2; i++) {\n        scratch += this.analysis.raw[i];\n      }\n\n      this.analysis.mid = scratch / third / 256; // highs\n\n      scratch = 0;\n\n      for (i = third * 2; i < this.bufferLength; i++) {\n        scratch += this.analysis.raw[i];\n      }\n\n      this.analysis.high = scratch / third / 256;\n      return this.analysis;\n    }\n  }]);\n\n  return AnalyserNode;\n}();\n\n/* harmony default export */ var nodes_AnalyserNode = (AnalyserNode); // module.exports = AnalyserNode\n// CONCATENATED MODULE: ./src/modules/nodes/allNodes.js\n/*\n\n  Gather all nodes in a single export.\n\n  All nodes must implement this API:\n\n    let n = new Node({\n      lastNode: Node,\n      context:  WebAudioContext,\n    })\n    n.connect(lastNode)\n\n\n  ie\n\n  class MyNode {\n    constructor(params){\n      let ctx = params.context\n      this.myNode = ctx.createNodeType ? ctx.createNodeType() : ctx.createType()\n\n      // additional setup here\n    }\n\n    connect(previousNode){\n      previousNode.connect(this.myNode)\n      return this.myNode\n    }\n  }\n\n*/\n\n\n\n\n/* harmony default export */ var allNodes = ({\n  GainNode: nodes_GainNode,\n  PannerNode2D: nodes_PannerNode2D,\n  PannerNode: PannerNode,\n  AnalyserNode: nodes_AnalyserNode\n});\n// CONCATENATED MODULE: ./src/modules/WebAudioTrack.js\nfunction WebAudioTrack_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { WebAudioTrack_typeof = function _typeof(obj) { return typeof obj; }; } else { WebAudioTrack_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return WebAudioTrack_typeof(obj); }\n\nfunction WebAudioTrack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction WebAudioTrack_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction WebAudioTrack_createClass(Constructor, protoProps, staticProps) { if (protoProps) WebAudioTrack_defineProperties(Constructor.prototype, protoProps); if (staticProps) WebAudioTrack_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction WebAudioTrack_possibleConstructorReturn(self, call) { if (call && (WebAudioTrack_typeof(call) === "object" || typeof call === "function")) { return call; } return WebAudioTrack_assertThisInitialized(self); }\n\nfunction WebAudioTrack_getPrototypeOf(o) { WebAudioTrack_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return WebAudioTrack_getPrototypeOf(o); }\n\nfunction WebAudioTrack_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction WebAudioTrack_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) WebAudioTrack_setPrototypeOf(subClass, superClass); }\n\nfunction WebAudioTrack_setPrototypeOf(o, p) { WebAudioTrack_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return WebAudioTrack_setPrototypeOf(o, p); }\n\n/*\n\n  Web Audio API track - to be extended\n\n    adds node functionality to base track\n\n*/\n\n\n\n\nvar WebAudioTrack_WebAudioTrack =\n/*#__PURE__*/\nfunction (_BaseTrack) {\n  WebAudioTrack_inherits(WebAudioTrack, _BaseTrack);\n\n  function WebAudioTrack(params) {\n    var _this;\n\n    WebAudioTrack_classCallCheck(this, WebAudioTrack);\n\n    _this = WebAudioTrack_possibleConstructorReturn(this, WebAudioTrack_getPrototypeOf(WebAudioTrack).call(this, params));\n\n    var track = WebAudioTrack_assertThisInitialized(_this);\n\n    var defaults = {\n      src: \'\',\n      context: false,\n      nodes: []\n    };\n    track.options = Object.assign(defaults, params);\n    track.data = {}; // reference nodes by ???\n\n    track.allNodes = [];\n    track.nodeLookup = {};\n    return _this;\n  }\n  /*\n     input is an array\n   */\n\n\n  WebAudioTrack_createClass(WebAudioTrack, [{\n    key: "createNodes",\n    value: function createNodes(nodes, source) {\n      var track = this;\n\n      if (!source) {\n        throw new Error(\'Can’t create nodes without a valid source.\');\n      } else if (!source.connect) {\n        throw new Error(\'Can’t create nodes without a valid source.\');\n      } // clear previous set of nodes (we recreate nodes every time we play)\n\n\n      track.allNodes = [];\n      var previousNode = source;\n      nodes.forEach(function (n) {\n        var baseParams = {\n          context: track.options.context // determine node type by duck typing\n\n        };\n\n        if (typeof n === \'string\') {\n          // predefined node with all defaults, no options\n          if (allNodes[n]) {\n            var newNode = new allNodes[n](baseParams);\n            track.allNodes.push(newNode);\n            track.nodeLookup[n] = newNode;\n            previousNode.connect(newNode.node);\n            previousNode = newNode.node;\n          } else {\n            throw new Error("Node type ".concat(n, " does not exist."));\n          }\n        } else if (WebAudioTrack_typeof(n) === \'object\') {\n          if (n.type) {\n            // create predefined node with options\n            var nodeType = allNodes[n.type];\n\n            if (nodeType) {\n              var _newNode = new nodeType(Object.assign(baseParams, n.options));\n\n              track.allNodes.push(_newNode);\n              track.nodeLookup[n.type] = _newNode;\n              previousNode.connect(_newNode.node);\n              previousNode = _newNode.node;\n            } else {\n              throw new Error("Node type ".concat(n.type, " does not exist."));\n            }\n          } else if (n.node) {\n            // create custom node, this is a raw node object\n            track.allNodes.push(n);\n            previousNode.connect(n.node);\n            previousNode = n.node;\n          }\n        }\n      });\n      previousNode.connect(track.options.context.destination);\n    }\n  }, {\n    key: "nodes",\n    value: function nodes() {\n      return this.allNodes;\n    }\n  }, {\n    key: "node",\n    value: function node(id) {\n      return this.nodeLookup[id] || false;\n    }\n  }]);\n\n  return WebAudioTrack;\n}(modules_BaseTrack);\n\n/* harmony default export */ var modules_WebAudioTrack = (WebAudioTrack_WebAudioTrack);\n// CONCATENATED MODULE: ./src/modules/BufferSourceTrack.js\nfunction BufferSourceTrack_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { BufferSourceTrack_typeof = function _typeof(obj) { return typeof obj; }; } else { BufferSourceTrack_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return BufferSourceTrack_typeof(obj); }\n\nfunction BufferSourceTrack_toConsumableArray(arr) { return BufferSourceTrack_arrayWithoutHoles(arr) || BufferSourceTrack_iterableToArray(arr) || BufferSourceTrack_nonIterableSpread(); }\n\nfunction BufferSourceTrack_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction BufferSourceTrack_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction BufferSourceTrack_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction BufferSourceTrack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction BufferSourceTrack_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction BufferSourceTrack_createClass(Constructor, protoProps, staticProps) { if (protoProps) BufferSourceTrack_defineProperties(Constructor.prototype, protoProps); if (staticProps) BufferSourceTrack_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction BufferSourceTrack_possibleConstructorReturn(self, call) { if (call && (BufferSourceTrack_typeof(call) === "object" || typeof call === "function")) { return call; } return BufferSourceTrack_assertThisInitialized(self); }\n\nfunction BufferSourceTrack_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction BufferSourceTrack_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { BufferSourceTrack_get = Reflect.get; } else { BufferSourceTrack_get = function _get(target, property, receiver) { var base = BufferSourceTrack_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return BufferSourceTrack_get(target, property, receiver || target); }\n\nfunction BufferSourceTrack_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = BufferSourceTrack_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction BufferSourceTrack_getPrototypeOf(o) { BufferSourceTrack_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return BufferSourceTrack_getPrototypeOf(o); }\n\nfunction BufferSourceTrack_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) BufferSourceTrack_setPrototypeOf(subClass, superClass); }\n\nfunction BufferSourceTrack_setPrototypeOf(o, p) { BufferSourceTrack_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return BufferSourceTrack_setPrototypeOf(o, p); }\n\n/*\n\n  Web Audio API: Buffer Source track\n\n*/\n\n\n\n\nvar BufferSourceTrack_BufferSourceTrack =\n/*#__PURE__*/\nfunction (_WebAudioTrack) {\n  BufferSourceTrack_inherits(BufferSourceTrack, _WebAudioTrack);\n\n  function BufferSourceTrack(params) {\n    var _this;\n\n    BufferSourceTrack_classCallCheck(this, BufferSourceTrack);\n\n    _this = BufferSourceTrack_possibleConstructorReturn(this, BufferSourceTrack_getPrototypeOf(BufferSourceTrack).call(this, params));\n\n    var track = BufferSourceTrack_assertThisInitialized(_this);\n\n    var defaults = {\n      id: \'\',\n      src: \'\',\n      volume: 1,\n      start: 0,\n      loop: false,\n      autoplay: false,\n      autoload: true,\n      context: false,\n      mix: false,\n      nodes: []\n    };\n    track.options = Object.assign(defaults, params);\n    track.status = {\n      ready: false,\n      shouldPlayOnLoad: false,\n      playing: false,\n      muted: track.options.muted || false // internal flags and data\n\n    };\n    track.data = {\n      gain: track.options.volume,\n      // manual time tracking\n      cachedTime: 0,\n      startTime: 0\n    };\n\n    if (!track.options.context) {\n      throw new Error(\'Can’t create a WebAudioTrack without Web Audio API support\');\n    }\n\n    if (!track.options.src) {\n      throw new Error(\'Can’t create a WebAudioTrack without a src parameter\');\n    } // limited subset of events available because they\'re all simulated\n\n\n    var eventNames = [\'loadstart\', \'loadedmetadata\', \'canplay\', \'canplaythrough\', \'play\', \'pause\', \'ended\', \'error\']; // load the source the right away, even if autoplay isn\'t set.\n\n    if (track.options.autoload || track.options.autoplay) {\n      track.load();\n    }\n\n    return _this;\n  }\n  /*\n     Playback needs to wait for the track to be loaded.\n    After this, it\'s a synchronous function.\n     You can listen for the \'canplaythrough\' event to ensure\n    synchronous playback of multiple buffer tracks.\n   */\n\n\n  BufferSourceTrack_createClass(BufferSourceTrack, [{\n    key: "play",\n    value: function play() {\n      var track = this; // this logic accomodates calling play() multiple times\n      // while waiting for the track to be set up\n\n      if (track.status.playing) return track;\n\n      if (!track.status.ready) {\n        if (!track.options.autoload && !track.status.shouldPlayOnLoad) {\n          track.load();\n        }\n\n        track.status.shouldPlayOnLoad = true;\n        return track;\n      }\n      /*\n         if we got this far we\'re actually ready to play, let\'s go!\n       */\n\n\n      var ctx = track.options.context; // the buffer needs to be re-created every time we play()\n\n      track.data.source = ctx.createBufferSource();\n      track.data.source.buffer = track.data.decodedBuffer; // track.data.source.loop = (track.options.loop) ? true : false\n      // as do the nodes\n\n      var gainNode = {\n        type: \'GainNode\',\n        options: {\n          gain: track.data.gain\n        }\n      };\n\n      BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "createNodes", this).call(this, [gainNode].concat(BufferSourceTrack_toConsumableArray(track.options.nodes)), track.data.source);\n\n      track.data.startTime = track.data.source.context.currentTime - track.data.cachedTime;\n      var startFrom = track.data.cachedTime || 0; // prefer start() but fall back to older, deprecated noteOn()\n\n      if (typeof track.data.source.start === \'function\') {\n        track.data.source.start(0, startFrom);\n      } else {\n        track.data.source.noteOn(startFrom);\n      }\n\n      track.setEndTimer();\n      track.status.playing = true;\n\n      BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", this).call(this, \'play\', track);\n\n      return track;\n    }\n    /*\n       Buffer source mode requires the source file to be fully loaded\n      and decoded before it can be play, so here we fetch it as an\n      array buffer (because it needs to be in raw binary format to be\n      decoded).\n       Web Audio API has the same browser support as fetch (no IE,\n      not even 11), so we can use this delightful method.\n     */\n\n  }, {\n    key: "load",\n    value: function load() {\n      var _this2 = this;\n\n      var track = this;\n      var ctx = track.options.context;\n\n      BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", this).call(this, \'loadstart\');\n\n      return window.fetch(track.options.src).then(function (res) {\n        return res.arrayBuffer();\n      }).then(function (audioData) {\n        track.data.audioData = audioData; // Decode audio data\n\n        if (typeof ctx.createGain === \'function\') {\n          // W3C standard implementation - async (Firefox, recent Chrome)\n          return new Promise(function (resolve, reject) {\n            ctx.decodeAudioData(audioData, function (decodedBuffer) {\n              track.data.decodedBuffer = decodedBuffer;\n              resolve();\n            });\n          });\n        } else if (typeof ctx.createGainNode === \'function\') {\n          // Non-standard Webkit implementation (Safari, old Chrome)\n          // not async but we fake it for consistency\n          var decodedBuffer = ctx.createBuffer(audioData, true);\n          track.data.decodedBuffer = decodedBuffer;\n          return Promise.resolve();\n        }\n      }).then(function () {\n        track.status.ready = true; // now that the source is decoded, we know its duration\n\n        BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", _this2).call(_this2, \'loadedmetadata\');\n\n        BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", _this2).call(_this2, \'canplay\');\n\n        BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", _this2).call(_this2, \'canplaythrough\');\n\n        if (track.options.autoplay || track.status.shouldPlayOnLoad) {\n          track.play();\n        }\n      });\n    }\n    /*\n       Buffer tracks don\'t have an ended event so we simulate it using setTimeout\n     */\n\n  }, {\n    key: "setEndTimer",\n    value: function setEndTimer() {\n      var track = this;\n      var startFrom = track.data.cachedTime || 0;\n      track.data.timerDuration = track.data.source.buffer.duration - startFrom;\n\n      if (track.data.onendtimer) {\n        window.clearTimeout(track.data.onendtimer);\n      }\n\n      track.data.onendtimer = window.setTimeout(track.ended.bind(track), track.data.timerDuration * 1000);\n    }\n  }, {\n    key: "ended",\n    value: function ended() {\n      var track = this;\n\n      if (track.options.loop) {\n        BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", this).call(this, \'ended\', track);\n\n        BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", this).call(this, \'loop\', track);\n\n        track.pause(0);\n        track.play();\n      } else {\n        track.status.playing = false;\n\n        BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", this).call(this, \'ended\', track);\n      }\n    } // end of play functions\n    // ********************************************************\n\n  }, {\n    key: "pause",\n    value: function pause(pauseAtTime) {\n      var track = this; // disable autoplay, if we\'ve paused the track before it\'s had a chance to load\n\n      if (!track.status.playing && track.status.shouldPlayOnLoad) {\n        track.status.shouldPlayOnLoad = false;\n        track.options.autoplay = false;\n        return track;\n      }\n\n      track.data.cachedTime = typeof pauseAtTime === \'number\' ? pauseAtTime : track.currentTime();\n      track.status.playing = false;\n      if (track.data.onendtimer) window.clearTimeout(track.data.onendtimer); // prefer stop(), fallback to deprecated noteOff()\n\n      if (typeof track.data.source.stop === \'function\') track.data.source.stop(0);else if (typeof track.data.source.noteOff === \'function\') track.data.source.noteOff(0);\n\n      BufferSourceTrack_get(BufferSourceTrack_getPrototypeOf(BufferSourceTrack.prototype), "trigger", this).call(this, \'pause\', track);\n\n      return track;\n    }\n  }, {\n    key: "currentTime",\n    value: function currentTime(setTo) {\n      var track = this;\n\n      if (typeof setTo === \'number\') {\n        if (track.status.playing) {\n          // to seek a buffer track, we need to pause and play\n          track.pause(setTo).play();\n        } else {\n          // if we\'re paused or not loaded yet, cache the time\n          track.data.cachedTime = setTo;\n        }\n\n        return track;\n      }\n\n      if (!track.status.ready || !track.status.playing) return track.data.cachedTime || 0;\n      return track.data.source.context.currentTime - track.data.startTime || 0;\n    }\n  }, {\n    key: "formattedTime",\n    value: function formattedTime(includeDuration) {\n      var track = this;\n      if (includeDuration) return utils.timeFormat(track.currentTime()) + \'/\' + utils.timeFormat(track.duration());else return utils.timeFormat(track.currentTime());\n    }\n  }, {\n    key: "duration",\n    value: function duration() {\n      var track = this;\n\n      if (!track.status.ready) {\n        return 0;\n      }\n\n      return track.data.source.buffer.duration || 0;\n    } // for a buffer track, volume() is basically an alias for the gain node\n\n  }, {\n    key: "volume",\n    value: function volume(setTo) {\n      var track = this;\n      var gainNode = track.node(\'GainNode\');\n\n      if (typeof setTo === \'number\') {\n        setTo = utils.normalize(setTo);\n\n        if (track.status.muted) {\n          track.data.gainCache = setTo; // cache the value for when we unmute\n\n          track.data.gain = 0;\n        } else {\n          track.data.gain = setTo;\n        }\n\n        if (track.status.playing) {\n          if (gainNode) gainNode.gain(track.options.mix ? track.data.gain * track.options.mix.volume() : track.data.gain);\n        }\n\n        return track;\n      } else {\n        // accurately report gain while we’re tweening it\n        if (track.status.playing) if (gainNode) track.data.gain = gainNode.gain();\n        return track.data.gain;\n      }\n    }\n  }, {\n    key: "tweenVolume",\n    value: function tweenVolume(setTo, duration) {\n      var track = this; // remove existing volume tween\n\n      if (track.volumeTween) {\n        window.cancelAnimationFrame(track.volumeTween);\n      } // if we\'re playing, we can use the gain node\'s native value ramp method\n\n\n      var gainNode = track.node(\'GainNode\');\n\n      if (gainNode) {\n        gainNode.tweenGain(setTo, duration);\n        return u.timeoutPromise(duration * 1000);\n      } // if we\'re not playing or haven\'t loaded yet,\n      // fall back to requestAnimationFrame\n\n\n      return new Promise(function (resolve, reject) {\n        var fps = 60; // requestAnimationFrame\n\n        var durationInFrames = Math.round(duration * fps);\n        var frameCount = Math.round(duration * fps);\n        var startVolume = track.volume();\n        var endVolume = utils.normalize(setTo);\n        tick();\n\n        function tick() {\n          if (frameCount <= 0) {\n            track.volume(endVolume);\n            resolve(track);\n          } else {\n            track.volumeTween = window.requestAnimationFrame(tick);\n          }\n\n          frameCount -= 1;\n          var progress = 1 - frameCount / durationInFrames;\n          var v = utils.lerp(startVolume, endVolume, progress);\n          track.volume(v);\n        }\n      });\n    }\n  }, {\n    key: "muted",\n    value: function muted(setTo) {\n      var track = this;\n\n      if (typeof setTo === \'boolean\') {\n        if (setTo === true) {\n          // mute: cache current gain, then set to 0\n          track.data.gainCache = track.data.gain;\n          track.volume(0);\n          track.status.muted = true;\n        } else {\n          // unmute\n          track.status.muted = false;\n          track.volume(track.data.gainCache);\n        }\n\n        return track;\n      }\n\n      return track.status.muted;\n    }\n  }, {\n    key: "paused",\n    value: function paused() {\n      var track = this;\n      return !track.status.playing;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      var track = this;\n      track.pause();\n    }\n  }]);\n\n  return BufferSourceTrack;\n}(modules_WebAudioTrack);\n\n/* harmony default export */ var modules_BufferSourceTrack = (BufferSourceTrack_BufferSourceTrack);\n// CONCATENATED MODULE: ./src/modules/ElementSourceTrack.js\nfunction ElementSourceTrack_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ElementSourceTrack_typeof = function _typeof(obj) { return typeof obj; }; } else { ElementSourceTrack_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ElementSourceTrack_typeof(obj); }\n\nfunction ElementSourceTrack_toConsumableArray(arr) { return ElementSourceTrack_arrayWithoutHoles(arr) || ElementSourceTrack_iterableToArray(arr) || ElementSourceTrack_nonIterableSpread(); }\n\nfunction ElementSourceTrack_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction ElementSourceTrack_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction ElementSourceTrack_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction ElementSourceTrack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ElementSourceTrack_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ElementSourceTrack_createClass(Constructor, protoProps, staticProps) { if (protoProps) ElementSourceTrack_defineProperties(Constructor.prototype, protoProps); if (staticProps) ElementSourceTrack_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction ElementSourceTrack_possibleConstructorReturn(self, call) { if (call && (ElementSourceTrack_typeof(call) === "object" || typeof call === "function")) { return call; } return ElementSourceTrack_assertThisInitialized(self); }\n\nfunction ElementSourceTrack_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction ElementSourceTrack_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) ElementSourceTrack_setPrototypeOf(subClass, superClass); }\n\nfunction ElementSourceTrack_setPrototypeOf(o, p) { ElementSourceTrack_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ElementSourceTrack_setPrototypeOf(o, p); }\n\nfunction ElementSourceTrack_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { ElementSourceTrack_get = Reflect.get; } else { ElementSourceTrack_get = function _get(target, property, receiver) { var base = ElementSourceTrack_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return ElementSourceTrack_get(target, property, receiver || target); }\n\nfunction ElementSourceTrack_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = ElementSourceTrack_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction ElementSourceTrack_getPrototypeOf(o) { ElementSourceTrack_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ElementSourceTrack_getPrototypeOf(o); }\n\n/*\n\n  Web Audio API: Element Source track\n\n*/\n\n\n\n\nvar ElementSourceTrack_ElementSourceTrack =\n/*#__PURE__*/\nfunction (_WebAudioTrack) {\n  ElementSourceTrack_inherits(ElementSourceTrack, _WebAudioTrack);\n\n  function ElementSourceTrack(params) {\n    var _this;\n\n    ElementSourceTrack_classCallCheck(this, ElementSourceTrack);\n\n    _this = ElementSourceTrack_possibleConstructorReturn(this, ElementSourceTrack_getPrototypeOf(ElementSourceTrack).call(this, params));\n\n    var track = ElementSourceTrack_assertThisInitialized(_this);\n\n    var defaults = {\n      id: \'\',\n      src: \'\',\n      volume: 1,\n      start: 0,\n      loop: false,\n      autoplay: false,\n      context: false,\n      mix: false,\n      nodes: []\n    };\n    track.options = Object.assign(defaults, params);\n\n    if (!track.options.context) {\n      throw new Error(\'Can’t create an ElementSourceTrack without Web Audio API support\');\n    } // set up our HTML5 <audio> element\n\n\n    if (!track.options.src) {\n      throw new Error(\'Can’t create an ElementSourceTrack without a src parameter\');\n    }\n\n    track.el = document.createElement(\'audio\');\n    track.el.volume = track.options.volume;\n    track.el.muted = track.options.muted;\n    track.el.loop = track.options.loop;\n    track.el.autoplay = track.options.autoplay;\n    track.el.src = track.options.src;\n    var eventNames = [\'loadstart\', \'loadedmetadata\', \'canplay\', \'canplaythrough\', \'play\', \'pause\', \'ended\', \'timeupdate\', \'seeking\', \'seeked\', \'error\'];\n    eventNames.forEach(function (eventName) {\n      track.el.addEventListener(eventName, ElementSourceTrack_get(ElementSourceTrack_getPrototypeOf(ElementSourceTrack.prototype), "trigger", ElementSourceTrack_assertThisInitialized(_this)).bind(track, eventName, false));\n    }); // web audio API setup (only needs to happen once)\n\n    track.data.source = track.options.context.createMediaElementSource(track.el);\n    var gainNode = {\n      type: \'GainNode\',\n      options: {\n        gain: track.data.gain\n      }\n    };\n\n    ElementSourceTrack_get(ElementSourceTrack_getPrototypeOf(ElementSourceTrack.prototype), "createNodes", ElementSourceTrack_assertThisInitialized(_this)).call(ElementSourceTrack_assertThisInitialized(_this), [gainNode].concat(ElementSourceTrack_toConsumableArray(track.options.nodes)), track.data.source);\n\n    return _this;\n  }\n\n  ElementSourceTrack_createClass(ElementSourceTrack, [{\n    key: "play",\n    value: function play() {\n      this.el.play();\n      return this;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      this.el.pause();\n      return this;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this.el.pause();\n      this.el.currentTime = 0;\n      return this;\n    }\n  }, {\n    key: "currentTime",\n    value: function currentTime(setTo) {\n      var track = this;\n\n      if (typeof setTo === \'number\') {\n        track.el.currentTime = setTo;\n        return track;\n      } else {\n        return track.el.currentTime;\n      }\n    }\n  }, {\n    key: "duration",\n    value: function duration() {\n      var track = this;\n      return track.el.duration;\n    }\n  }, {\n    key: "formattedTime",\n    value: function formattedTime(includeDuration) {\n      var track = this;\n      if (includeDuration) return utils.timeFormat(track.currentTime()) + \'/\' + utils.timeFormat(track.duration());else return utils.timeFormat(track.currentTime());\n    }\n  }, {\n    key: "volume",\n    value: function volume(setTo) {\n      var track = this;\n      var gainNode = track.node(\'GainNode\');\n\n      if (typeof setTo === \'number\') {\n        setTo = utils.normalize(setTo);\n        setTo = track.options.mix ? setTo * track.options.mix.volume() : setTo; // we don\'t need to set both the gain node and element volume,\n        // just the gain node will work, but element volume is a useful place\n        // to store the current volume value\n\n        if (gainNode) gainNode.gain(setTo);\n        track.el.volume = setTo;\n        return track;\n      } else {\n        return track.el.volume;\n      }\n    }\n  }, {\n    key: "tweenVolume",\n    value: function tweenVolume(setTo, duration) {\n      var track = this; // replace existing volume tween\n\n      if (track.volumeTween) {\n        window.cancelAnimationFrame(track.volumeTween);\n      }\n\n      return new Promise(function (resolve, reject) {\n        var fps = 60; // requestAnimationFrame\n\n        var durationInFrames = Math.round(duration * fps);\n        var frameCount = Math.round(duration * fps);\n        var startVolume = track.volume();\n        var endVolume = utils.normalize(setTo);\n        tick();\n\n        function tick() {\n          if (frameCount <= 0) {\n            track.volume(endVolume);\n            resolve(track);\n          } else {\n            track.volumeTween = window.requestAnimationFrame(tick);\n          }\n\n          frameCount -= 1;\n          var progress = 1 - frameCount / durationInFrames;\n          var v = utils.lerp(startVolume, endVolume, progress);\n          track.volume(v);\n        }\n      });\n    }\n  }, {\n    key: "muted",\n    value: function muted(setTo) {\n      var track = this;\n\n      if (typeof setTo === \'boolean\') {\n        track.el.muted = setTo;\n      }\n\n      return track.el.muted;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      var track = this;\n      track.pause();\n    }\n  }, {\n    key: "paused",\n    value: function paused() {\n      var track = this;\n      return track.el.paused;\n    }\n  }]);\n\n  return ElementSourceTrack;\n}(modules_WebAudioTrack);\n\n/* harmony default export */ var modules_ElementSourceTrack = (ElementSourceTrack_ElementSourceTrack);\n// CONCATENATED MODULE: ./src/modules/trackTypes.js\n/*\n\n  Track Types\n\n*/\n\n\n\n/* harmony default export */ var trackTypes = ({\n  Html5Track: modules_Html5Track,\n  BufferSourceTrack: modules_BufferSourceTrack,\n  ElementSourceTrack: modules_ElementSourceTrack\n});\n// CONCATENATED MODULE: ./src/modules/Mixer.js\nfunction Mixer_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Mixer_typeof = function _typeof(obj) { return typeof obj; }; } else { Mixer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Mixer_typeof(obj); }\n\nfunction Mixer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Mixer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Mixer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Mixer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Mixer_defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n\n  Audio Mixer\n\n*/\n\n\n\nvar Mixer_Mixer =\n/*#__PURE__*/\nfunction () {\n  function Mixer() {\n    Mixer_classCallCheck(this, Mixer);\n\n    var mix = this;\n    mix.allTracks = []; // tracks as numbered array\n\n    mix.lookup = {}; // tracks as lookup table: mix.lookup[\'trackname\']\n\n    mix.currentVolume = 1; // create a web audio context:\n    // FF, Chrome, Edge unprefixed\n    // Safari prefixed\n\n    if (window.AudioContext || window.webkitAudioContext) {\n      this.context = typeof window.AudioContext === \'function\' ? new window.AudioContext() : new window.webkitAudioContext();\n    }\n  }\n  /*\n     Create a new track, or return an existing track\n   */\n\n\n  Mixer_createClass(Mixer, [{\n    key: "track",\n    value: function track(id, params) {\n      var mix = this;\n\n      if (!id) {\n        throw new Error(\'Can’t create a track without a name\');\n        return;\n      } // track already exists, return it\n\n\n      if (mix.lookup[id]) {\n        return mix.lookup[id];\n      } else if (params) {\n        // if params are passed, create a track\n        var defaults = {\n          id: id,\n          timeline: [],\n          mix: mix,\n          context: mix.context,\n          type: trackTypes.Html5Track // default to standard track type\n\n        };\n        var options = Object.assign(defaults, params); // should be able to pass track type as string\n\n        if (typeof options.type === \'string\') {\n          if (trackTypes[options.type]) options.type = trackTypes[options.type];\n        }\n\n        var track = new options.type(options);\n        mix.allTracks.push(track);\n        mix.lookup[id] = track;\n        return track;\n      } else {\n        // this track doesn\'t exist, no params received\n        return false;\n      }\n    }\n  }, {\n    key: "tracks",\n    value: function tracks() {\n      var mix = this;\n      return mix.allTracks;\n    }\n    /*\n       Remove an existing track. Can receive an ID or a track object.\n     */\n\n  }, {\n    key: "remove",\n    value: function remove(input) {\n      var mix = this; // input can be either a string or a track object,\n      // but the track object needs to have an id property\n\n      var trackId;\n      if (typeof input === \'string\') trackId = input;else if (Mixer_typeof(input) === \'object\' && input.id) trackId = input.id;\n      var track = mix.lookup[trackId];\n\n      for (var i = mix.allTracks.length - 1; i >= 0; i--) {\n        if (mix.allTracks[i] === track) {\n          mix.allTracks.splice(i, 1);\n        }\n      }\n\n      if (track.destroy) track.destroy();\n      track = null;\n      delete mix.lookup[trackId];\n    }\n    /*\n       Set the master volume for the entire audio mixer.\n     */\n\n  }, {\n    key: "volume",\n    value: function volume(setTo) {\n      var mix = this;\n\n      if (typeof setTo === \'number\') {\n        mix.currentVolume = utils.normalize(setTo); // tracks multiply their volume by the mix’s volume, so\n        // whenever we change the master volume we need to call\n        // track.volume() once to get the intended result\n\n        mix.allTracks.forEach(function (track) {\n          return track.volume ? track.volume(track.volume()) : \'\';\n        });\n      }\n\n      return mix.currentVolume;\n    }\n  }]);\n\n  return Mixer;\n}();\n\n/* harmony default export */ var modules_Mixer = (Mixer_Mixer);\n// CONCATENATED MODULE: ./src/index.js\n/*\n\n  Audio Mixer\n\n*/\n\n\n/* harmony default export */ var src = __webpack_exports__["default"] = ({\n  Mixer: modules_Mixer,\n  Html5Track: modules_Html5Track\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvbW9kdWxlcy9CYXNlVHJhY2suanM/MzRlYiIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvbW9kdWxlcy91dGlscy5qcz8wODBmIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9tb2R1bGVzL0h0bWw1VHJhY2suanM/OGJlOSIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvbW9kdWxlcy9ub2Rlcy9HYWluTm9kZS5qcz9kOGY0Iiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9tb2R1bGVzL25vZGVzL1Bhbm5lck5vZGUyRC5qcz81ZTU3Iiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9tb2R1bGVzL25vZGVzL1Bhbm5lck5vZGUuanM/ODJjOCIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvbW9kdWxlcy9ub2Rlcy9BbmFseXNlck5vZGUuanM/MjhhOSIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvbW9kdWxlcy9ub2Rlcy9hbGxOb2Rlcy5qcz8xOTJhIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9tb2R1bGVzL1dlYkF1ZGlvVHJhY2suanM/ZGFkNCIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvbW9kdWxlcy9CdWZmZXJTb3VyY2VUcmFjay5qcz9mNTgzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9tb2R1bGVzL0VsZW1lbnRTb3VyY2VUcmFjay5qcz9iOTMyIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9tb2R1bGVzL3RyYWNrVHlwZXMuanM/YTkxNSIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvbW9kdWxlcy9NaXhlci5qcz9jYWVhIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9pbmRleC5qcz9iNjM1Il0sIm5hbWVzIjpbIkJhc2VUcmFjayIsInBhcmFtcyIsImlkIiwiZXZlbnRzIiwidGltZWxpbmVFdmVudHMiLCJldmVudE5hbWUiLCJjYWxsYmFjayIsInRyYWNrIiwiRXJyb3IiLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwid3JhcHBlZENhbGxiYWNrIiwib2ZmIiwib24iLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiZm4iLCJhcHBseSIsInRpbWUiLCJlIiwiaSIsImxlbmd0aCIsInRyaWdnZXJlZCIsIm5vcm1hbGl6ZSIsInZhbHVlIiwidGltZUZvcm1hdCIsInNlY29uZHMiLCJtIiwiTWF0aCIsImZsb29yIiwicyIsImxlcnAiLCJzdGFydCIsImVuZCIsIm5vdyIsInRpbWVvdXRQcm9taXNlIiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJIdG1sNVRyYWNrIiwiZGVmYXVsdHMiLCJzcmMiLCJ2b2x1bWUiLCJtdXRlZCIsImxvb3AiLCJhdXRvcGxheSIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJlbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImV2ZW50TmFtZXMiLCJhZGRFdmVudExpc3RlbmVyIiwiYmluZCIsInBsYXkiLCJwYXVzZSIsImN1cnJlbnRUaW1lIiwic2V0VG8iLCJpbmNsdWRlRHVyYXRpb24iLCJ1dGlscyIsInZvbHVtZVR3ZWVuIiwid2luZG93IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZWplY3QiLCJmcHMiLCJkdXJhdGlvbkluRnJhbWVzIiwicm91bmQiLCJmcmFtZUNvdW50Iiwic3RhcnRWb2x1bWUiLCJlbmRWb2x1bWUiLCJ0aWNrIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicHJvZ3Jlc3MiLCJ2IiwicGF1c2VkIiwiR2Fpbk5vZGUiLCJjdHgiLCJjb250ZXh0Iiwibm9kZSIsImNyZWF0ZUdhaW5Ob2RlIiwiY3JlYXRlR2FpbiIsImdhaW4iLCJzZXRUYXJnZXRBdFRpbWUiLCJ1IiwiZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSIsIlBhbm5lck5vZGUyRCIsImNyZWF0ZVBhbm5lciIsInZhbHVlcyIsInBhbiIsInBhblgiLCJwYW5ZIiwicGFuWiIsImFuZ2xlIiwiYW5nbGVSYWQiLCJ4IiwiY29zIiwieSIsInNpbiIsInoiLCJzZXRQb3NpdGlvbiIsIlBhbk5vZGUzRCIsIkFuYWx5c2VyTm9kZSIsImNyZWF0ZUFuYWx5c2VyIiwiYW5hbHlzZXJOb2RlIiwic21vb3RoaW5nVGltZUNvbnN0YW50IiwiZmZ0U2l6ZSIsInByb2Nlc3NvciIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsInByb2Nlc3Nvck5vZGUiLCJjb25uZWN0IiwiZGVzdGluYXRpb24iLCJidWZmZXJMZW5ndGgiLCJmcmVxdWVuY3lCaW5Db3VudCIsImFuYWx5c2lzIiwicmF3IiwiVWludDhBcnJheSIsImF2ZXJhZ2UiLCJsb3ciLCJtaWQiLCJoaWdoIiwidG8iLCJ0aGlyZCIsInNjcmF0Y2giLCJnZXRCeXRlRnJlcXVlbmN5RGF0YSIsIlBhbm5lck5vZGUiLCJXZWJBdWRpb1RyYWNrIiwibm9kZXMiLCJkYXRhIiwiYWxsTm9kZXMiLCJub2RlTG9va3VwIiwic291cmNlIiwicHJldmlvdXNOb2RlIiwibiIsImJhc2VQYXJhbXMiLCJOb2RlcyIsIm5ld05vZGUiLCJ0eXBlIiwibm9kZVR5cGUiLCJCdWZmZXJTb3VyY2VUcmFjayIsImF1dG9sb2FkIiwibWl4Iiwic3RhdHVzIiwicmVhZHkiLCJzaG91bGRQbGF5T25Mb2FkIiwicGxheWluZyIsImNhY2hlZFRpbWUiLCJzdGFydFRpbWUiLCJsb2FkIiwiY3JlYXRlQnVmZmVyU291cmNlIiwiYnVmZmVyIiwiZGVjb2RlZEJ1ZmZlciIsImdhaW5Ob2RlIiwic3RhcnRGcm9tIiwibm90ZU9uIiwic2V0RW5kVGltZXIiLCJmZXRjaCIsInRoZW4iLCJyZXMiLCJhcnJheUJ1ZmZlciIsImF1ZGlvRGF0YSIsImRlY29kZUF1ZGlvRGF0YSIsImNyZWF0ZUJ1ZmZlciIsInRpbWVyRHVyYXRpb24iLCJvbmVuZHRpbWVyIiwiY2xlYXJUaW1lb3V0IiwiZW5kZWQiLCJwYXVzZUF0VGltZSIsInN0b3AiLCJub3RlT2ZmIiwiZ2FpbkNhY2hlIiwidHdlZW5HYWluIiwiRWxlbWVudFNvdXJjZVRyYWNrIiwiY3JlYXRlTWVkaWFFbGVtZW50U291cmNlIiwiTWl4ZXIiLCJhbGxUcmFja3MiLCJsb29rdXAiLCJjdXJyZW50Vm9sdW1lIiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0IiwidGltZWxpbmUiLCJ0cmFja1R5cGVzIiwiaW5wdXQiLCJ0cmFja0lkIiwiZGVzdHJveSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7SUFPTUEsUzs7O0FBQ0oscUJBQVlDLE1BQVosRUFBbUI7QUFBQTs7QUFDakIsU0FBS0MsRUFBTCxHQUFVRCxNQUFNLENBQUNDLEVBQWpCO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLEVBQWQ7QUFDQSxTQUFLQyxjQUFMLEdBQXNCSCxNQUFNLENBQUNHLGNBQVAsc0JBQTRCSCxNQUFNLENBQUNHLGNBQW5DLElBQXFELEVBQTNFO0FBQ0Q7Ozs7OEJBRVEsQ0FBRTtBQUVYOzs7Ozs7dUJBS0dDLFMsRUFBV0MsUSxFQUFTO0FBQ3JCLFVBQUlDLEtBQUssR0FBRyxJQUFaOztBQUVBLFVBQUcsT0FBT0YsU0FBUCxLQUFxQixRQUF4QixFQUFpQztBQUMvQixjQUFNLElBQUlHLEtBQUosQ0FBVSw4QkFBVixDQUFOO0FBQ0QsT0FGRCxNQUVPLElBQUcsQ0FBQ0YsUUFBSixFQUFjO0FBQ25CLGNBQU0sSUFBSUUsS0FBSixDQUFVLDZDQUFWLENBQU47QUFDRCxPQUZNLE1BRUE7QUFDTCxZQUFHRCxLQUFLLENBQUNKLE1BQU4sQ0FBYUUsU0FBYixDQUFILEVBQTJCO0FBQ3pCRSxlQUFLLENBQUNKLE1BQU4sQ0FBYUUsU0FBYixFQUF3QkksSUFBeEIsQ0FBNkJILFFBQTdCO0FBQ0QsU0FGRCxNQUVPO0FBQ0xDLGVBQUssQ0FBQ0osTUFBTixDQUFhRSxTQUFiLElBQTBCLENBQUNDLFFBQUQsQ0FBMUI7QUFDRDtBQUNGOztBQUVELGFBQU9DLEtBQVA7QUFDRDs7O3dCQUVHRixTLEVBQVdDLFEsRUFBUztBQUN0QixV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QWxEO0FBQUEsU0FBM0I7QUFDRDs7QUFDRCxhQUFPbUcsR0FBRyxDQUFDb0MsYUFBWDtBQUNEOzs7Ozs7QUFJWUgsNkRBQWYsRTs7QUNwSUE7Ozs7O0FBS0E7QUFDQTtBQUVlO0FBQUVBLE9BQUssRUFBTEEsYUFBRjtBQUFTdkksWUFBVSxFQUFWQSxrQkFBVUE7QUFBbkIsQ0FBZiIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblxuICBiYXNlIFRyYWNrIGNsYXNzLCB3aXRoIGV2ZW50IGFuZCB0aW1lbGluZSBmdW5jdGlvbmFsaXR5XG5cbiovXG5cblxuY2xhc3MgQmFzZVRyYWNrIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKXtcbiAgICB0aGlzLmlkID0gcGFyYW1zLmlkXG4gICAgdGhpcy5ldmVudHMgPSB7fVxuICAgIHRoaXMudGltZWxpbmVFdmVudHMgPSBwYXJhbXMudGltZWxpbmVFdmVudHMgPyBbLi4ucGFyYW1zLnRpbWVsaW5lRXZlbnRzXSA6IFtdXG4gIH1cblxuICBkZXN0cm95KCl7fVxuXG4gIC8qXG5cbiAgICBFdmVudHNcblxuICAqL1xuICBvbihldmVudE5hbWUsIGNhbGxiYWNrKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG5cbiAgICBpZih0eXBlb2YgZXZlbnROYW1lICE9PSAnc3RyaW5nJyl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IG5hbWUgbXVzdCBiZSBhIHN0cmluZy4nKVxuICAgIH0gZWxzZSBpZighY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fu4oCZdCByZWdpc3RlciBhbiBldmVudCB3aXRob3V0IGEgY2FsbGJhY2suJylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYodHJhY2suZXZlbnRzW2V2ZW50TmFtZV0pe1xuICAgICAgICB0cmFjay5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2suZXZlbnRzW2V2ZW50TmFtZV0gPSBbY2FsbGJhY2tdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrXG4gIH1cblxuICBvZmYoZXZlbnROYW1lLCBjYWxsYmFjayl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgaWYoY2FsbGJhY2spe1xuICAgICAgLy8gcmVtb3ZlIHNwZWNpZmljIGNhbGxiYWNrXG4gICAgICBpZih0cmFjay5ldmVudHNbZXZlbnROYW1lXSl7XG4gICAgICAgIGxldCBpbmRleCA9IHRyYWNrLmV2ZW50c1tldmVudE5hbWVdLmluZGV4T2YoY2FsbGJhY2spXG4gICAgICAgIHRyYWNrLmV2ZW50c1tldmVudE5hbWVdLnNwbGljZShpbmRleCwxKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgYSBnaXZlbiBldmVudCBuYW1lXG4gICAgICBpZih0cmFjay5ldmVudHNbZXZlbnROYW1lXSl7XG4gICAgICAgIHRyYWNrLmV2ZW50c1tldmVudE5hbWVdID0gW11cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJhY2tcbiAgfVxuXG4gIG9uZShldmVudE5hbWUsIGNhbGxiYWNrKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG5cbiAgICBsZXQgd3JhcHBlZENhbGxiYWNrID0gZnVuY3Rpb24oKXtcbiAgICAgIHRyYWNrLm9mZihldmVudE5hbWUsIHdyYXBwZWRDYWxsYmFjaylcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0cmFjay5vbihldmVudE5hbWUsIHdyYXBwZWRDYWxsYmFjaylcblxuICAgIHJldHVybiB0cmFja1xuICB9XG5cbiAgdHJpZ2dlcihldmVudE5hbWUpe1xuICAgIGxldCB0cmFjayA9IHRoaXNcblxuICAgIGlmKHRyYWNrLmV2ZW50c1tldmVudE5hbWVdKXtcbiAgICAgIGxldCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgdHJhY2suZXZlbnRzW2V2ZW50TmFtZV0uZm9yRWFjaChmbiA9PiBmbi5hcHBseSh0cmFjaywgYXJncykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrXG4gIH1cblxuXG4gIC8qXG5cbiAgICBUaW1lbGluZVxuXG4gICAgICBjaGVjayBpZiBhbnkgZXZlbnRzIG5lZWQgdG8gYmUgdHJpZ2dlcmVkXG5cbiAgICAgIHRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBtaXhlciB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblxuICAqL1xuXG4gIHVwZGF0ZVRpbWVsaW5lRXZlbnRzKHRpbWUpe1xuICAgIGxldCB0cmFjayA9IHRoaXNcbiAgICBsZXQgZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2sudGltZWxpbmVFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGUgPSB0cmFjay50aW1lbGluZUV2ZW50c1tpXVxuICAgICAgaWYodGltZSA+PSBlLnRpbWUgJiYgIWUudHJpZ2dlcmVkKXtcbiAgICAgICAgZS50cmlnZ2VyZWQgPSB0cnVlXG4gICAgICAgIGlmKGUuY2FsbGJhY2spXG4gICAgICAgICAgZS5jYWxsYmFjay5jYWxsKHRyYWNrKVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVRyYWNrXG4iLCJcbmZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWx1ZSl7XG4gIGlmKHZhbHVlID4gMSkgcmV0dXJuIDFcbiAgaWYodmFsdWUgPCAwKSByZXR1cm4gMFxuICByZXR1cm4gdmFsdWVcbn1cblxuZnVuY3Rpb24gdGltZUZvcm1hdChzZWNvbmRzKSB7XG4gIHZhciBtID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApIDwgMTAgPyAnMCcgKyBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCkgOiBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG4gIHZhciBzID0gTWF0aC5mbG9vcihzZWNvbmRzIC0gKG0gKiA2MCkpIDwgMTAgPyAnMCcgKyBNYXRoLmZsb29yKHNlY29uZHMgLSAobSAqIDYwKSkgOiBNYXRoLmZsb29yKHNlY29uZHMgLSAobSAqIDYwKSk7XG4gIHJldHVybiBtICsgJzonICsgcztcbn1cblxuZnVuY3Rpb24gbGVycChzdGFydCwgZW5kLCBub3cpIHtcbiAgcmV0dXJuICgxIC0gbm93KSAqIHN0YXJ0ICsgbm93ICogZW5kO1xufVxuXG5mdW5jdGlvbiB0aW1lb3V0UHJvbWlzZShkdXJhdGlvbil7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgZHVyYXRpb24pXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgbm9ybWFsaXplLCB0aW1lRm9ybWF0LCBsZXJwLCB0aW1lb3V0UHJvbWlzZSB9XG4iLCIvKlxuXG4gIEhUTUw1IDxhdWRpbz4gZWxlbWVudCB0cmFja1xuXG4qL1xuaW1wb3J0IEJhc2VUcmFjayBmcm9tICcuL0Jhc2VUcmFjaydcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJ1xuXG5jbGFzcyBIdG1sNVRyYWNrIGV4dGVuZHMgQmFzZVRyYWNrIHtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMpe1xuICAgIC8vIGNhbGwgdGhlIHBhcmVudCBjbGFzc+KAmXMgY29uc3RydWN0b3JcbiAgICBzdXBlcihwYXJhbXMpXG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgbGV0IGRlZmF1bHRzID0ge1xuICAgICAgaWQ6ICAgICAgICcnLFxuICAgICAgc3JjOiAgICAgICcnLFxuICAgICAgdm9sdW1lOiAgIDEsXG4gICAgICBtdXRlZDogICAgZmFsc2UsXG4gICAgICBzdGFydDogICAgMCxcbiAgICAgIGxvb3A6ICAgICBmYWxzZSxcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICB9XG5cbiAgICB0cmFjay5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgcGFyYW1zKVxuXG4gICAgLy8gc2V0IHVwIG91ciBIVE1MNSA8YXVkaW8+IGVsZW1lbnRcbiAgICBpZighdHJhY2sub3B0aW9ucy5zcmMpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW7igJl0IGNyZWF0ZSBhbiBIdG1sNVRyYWNrIHdpdGhvdXQgYSBzcmMgcGFyYW1ldGVyJylcbiAgICB9XG5cbiAgICB0cmFjay5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJylcblxuICAgIHRyYWNrLmVsLnZvbHVtZSAgID0gdHJhY2sub3B0aW9ucy52b2x1bWVcbiAgICB0cmFjay5lbC5tdXRlZCAgICA9IHRyYWNrLm9wdGlvbnMubXV0ZWRcbiAgICB0cmFjay5lbC5sb29wICAgICA9IHRyYWNrLm9wdGlvbnMubG9vcFxuICAgIHRyYWNrLmVsLmF1dG9wbGF5ID0gdHJhY2sub3B0aW9ucy5hdXRvcGxheVxuXG4gICAgdHJhY2suZWwuc3JjID0gdHJhY2sub3B0aW9ucy5zcmNcblxuICAgIGxldCBldmVudE5hbWVzID0gW1xuICAgICAgJ2xvYWRzdGFydCcsICdsb2FkZWRtZXRhZGF0YScsXG4gICAgICAnY2FucGxheScsICdjYW5wbGF5dGhyb3VnaCcsXG4gICAgICAncGxheScsICdwYXVzZScsXG4gICAgICAnZW5kZWQnLCAndGltZXVwZGF0ZScsXG4gICAgICAnc2Vla2luZycsICdzZWVrZWQnLFxuICAgICAgJ2Vycm9yJyxcbiAgICBdO1xuXG4gICAgZXZlbnROYW1lcy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICB0cmFjay5lbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgc3VwZXIudHJpZ2dlci5iaW5kKHRyYWNrLCBldmVudE5hbWUsIGZhbHNlKSlcbiAgICB9KVxuXG5cbiAgfVxuXG4gIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgcGxheSgpe1xuICAgIHRoaXMuZWwucGxheSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBhdXNlKCl7XG4gICAgdGhpcy5lbC5wYXVzZSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0b3AoKXtcbiAgICB0aGlzLmVsLnBhdXNlKClcbiAgICB0aGlzLmVsLmN1cnJlbnRUaW1lID0gMFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjdXJyZW50VGltZShzZXRUbyl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuICAgIGlmKHR5cGVvZiBzZXRUbyA9PT0gJ251bWJlcicpe1xuICAgICAgdHJhY2suZWwuY3VycmVudFRpbWUgPSBzZXRUb1xuICAgICAgcmV0dXJuIHRyYWNrXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cmFjay5lbC5jdXJyZW50VGltZVxuICAgIH1cbiAgfVxuXG4gIGR1cmF0aW9uKCl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuICAgIHJldHVybiB0cmFjay5lbC5kdXJhdGlvblxuICB9XG5cbiAgZm9ybWF0dGVkVGltZShpbmNsdWRlRHVyYXRpb24pe1xuICAgIGxldCB0cmFjayA9IHRoaXNcbiAgICBpZihpbmNsdWRlRHVyYXRpb24pXG4gICAgICByZXR1cm4gdXRpbHMudGltZUZvcm1hdCh0cmFjay5jdXJyZW50VGltZSgpKSArICcvJyArIHV0aWxzLnRpbWVGb3JtYXQodHJhY2suZHVyYXRpb24oKSk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHV0aWxzLnRpbWVGb3JtYXQodHJhY2suY3VycmVudFRpbWUoKSk7XG4gIH1cblxuICB2b2x1bWUoc2V0VG8pe1xuICAgIGxldCB0cmFjayA9IHRoaXNcbiAgICBpZih0eXBlb2Ygc2V0VG8gPT09ICdudW1iZXInKXtcbiAgICAgIHRyYWNrLmVsLnZvbHVtZSA9IHV0aWxzLm5vcm1hbGl6ZShzZXRUbylcbiAgICAgIHJldHVybiB0cmFja1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhY2suZWwudm9sdW1lXG4gICAgfVxuICB9XG5cbiAgdHdlZW5Wb2x1bWUoc2V0VG8sIGR1cmF0aW9uKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG5cbiAgICAvLyByZXBsYWNlIGV4aXN0aW5nIHZvbHVtZSB0d2VlblxuICAgIGlmKHRyYWNrLnZvbHVtZVR3ZWVuKXtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0cmFjay52b2x1bWVUd2VlbilcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcblxuICAgICAgbGV0IGZwcyA9IDYwIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgbGV0IGR1cmF0aW9uSW5GcmFtZXMgPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogZnBzKVxuICAgICAgbGV0IGZyYW1lQ291bnQgICAgICAgPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogZnBzKVxuICAgICAgbGV0IHN0YXJ0Vm9sdW1lICAgICAgPSB0cmFjay52b2x1bWUoKVxuICAgICAgbGV0IGVuZFZvbHVtZSAgICAgICAgPSB1dGlscy5ub3JtYWxpemUoc2V0VG8pXG5cbiAgICAgIHRpY2soKVxuXG4gICAgICBmdW5jdGlvbiB0aWNrKCl7XG4gICAgICAgIGlmKGZyYW1lQ291bnQgPD0gMCl7XG4gICAgICAgICAgdHJhY2sudm9sdW1lKGVuZFZvbHVtZSlcbiAgICAgICAgICByZXNvbHZlKHRyYWNrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYWNrLnZvbHVtZVR3ZWVuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKVxuICAgICAgICB9XG5cbiAgICAgICAgZnJhbWVDb3VudCAtPSAxXG4gICAgICAgIGxldCBwcm9ncmVzcyA9ICgxIC0gKGZyYW1lQ291bnQgLyBkdXJhdGlvbkluRnJhbWVzKSlcbiAgICAgICAgbGV0IHYgPSB1dGlscy5sZXJwKHN0YXJ0Vm9sdW1lLCBlbmRWb2x1bWUsIHByb2dyZXNzKVxuICAgICAgICB0cmFjay52b2x1bWUoIHYgKVxuICAgICAgfVxuXG4gICAgfSlcbiAgfVxuXG4gIG11dGVkKHNldFRvKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG4gICAgaWYodHlwZW9mIHNldFRvID09PSAnYm9vbGVhbicpe1xuICAgICAgdHJhY2suZWwubXV0ZWQgPSBzZXRUb1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2suZWwubXV0ZWRcbiAgfVxuXG4gIHBhdXNlZCgpe1xuICAgIGxldCB0cmFjayA9IHRoaXNcbiAgICByZXR1cm4gdHJhY2suZWwucGF1c2VkXG4gIH1cblxuICBkZXN0cm95KCl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuICAgIHRyYWNrLnBhdXNlKClcbiAgfVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSHRtbDVUcmFja1xuIiwiLypcblxuICBHYWluIE5vZGVcblxuICBsZXQgZyA9IG5ldyBHYWluTm9kZSh7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBnYWluOiAgICAxLFxuICB9KVxuXG4gIGcubm9kZSAtPiB0aGUgd2ViIGF1ZGlvIG5vZGUgb2JqZWN0XG5cbiAgZy5nYWluKHNldFRvKSAtPiBnZXR0ZXIvc2V0dGVyXG4gIGcubXV0ZWQoc2V0VG8pIC0+IGdldHRlci9zZXR0ZXJcblxuICBnLnR3ZWVuR2FpbihzZXRUbywgZHVyYXRpb24pXG5cbiovXG5pbXBvcnQgdSBmcm9tICcuLi91dGlscydcblxuY2xhc3MgR2Fpbk5vZGUge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpe1xuICAgIHRoaXMuY3R4ID0gcGFyYW1zLmNvbnRleHRcbiAgICB0aGlzLm5vZGUgPSB0aGlzLmN0eC5jcmVhdGVHYWluTm9kZSA/IHRoaXMuY3R4LmNyZWF0ZUdhaW5Ob2RlKCkgOiB0aGlzLmN0eC5jcmVhdGVHYWluKClcblxuICAgIHRoaXMuZ2FpbiggdHlwZW9mIHBhcmFtcy5nYWluID09PSAnbnVtYmVyJyA/IHBhcmFtcy5nYWluIDogMSApXG4gIH1cblxuICBnYWluKHNldFRvKXtcbiAgICBpZih0eXBlb2Ygc2V0VG8gPT09ICdudW1iZXInKXtcbiAgICAgIC8qXG5cbiAgICAgICAgJ0F1ZGlvUGFyYW0gdmFsdWUgc2V0dGVyIHdpbGwgYmVjb21lIGVxdWl2YWxlbnQgdG8gQXVkaW9QYXJhbS5zZXRWYWx1ZUF0VGltZSgpIGluIChDaHJvbWUpIE02NSdcblxuICAgICAgICBBcHBhcmVudGx5LCBpdCdzIGJhZCBmb3JtIHRvIHNldCBnYWluLnZhbHVlIGRpcmVjdGx5IG5vdywgaWVcbiAgICAgICAgJ3RoaXMubm9kZS5nYWluLnZhbHVlID0gdS5ub3JtYWxpemUoc2V0VG8sIDAsIDEpJ1xuXG4gICAgICAgIFJlY29tbWVuZGVkIGJlaGF2aW91ciBub3cgaXMgdG8gdXNlIHNldFRhcmdldEF0VGltZS5cblxuICAgICAgICAtIGh0dHBzOi8vd3d3LmNocm9tZXN0YXR1cy5jb20vZmVhdHVyZXMvNTI4Nzk5NTc3MDkyOTE1MlxuICAgICAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8xMTEzM1xuXG4gICAgICAqL1xuXG4gICAgICAvLyBzZXRUYXJnZXRBdFRpbWUoIHZhbHVlLCBzdGFydCB0aW1lIChjbGFtcGVkIHRvIGN1cnJlbnQgdGltZSksIHRpbWUgY29uc3RhbnQgKVxuICAgICAgdGhpcy5ub2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHUubm9ybWFsaXplKHNldFRvKSwgdGhpcy5jdHguY3VycmVudFRpbWUsIDApXG5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9kZS5nYWluLnZhbHVlXG4gIH1cblxuXG4gIC8vIHR3ZWVuR2FpbigwLCAxLCAnbGluZWFyJylcbiAgdHdlZW5HYWluKHNldFRvLCBkdXJhdGlvbil7XG4gICAgLy8gdXNpbmcgYW4gZXhwb25lbnRpYWwgcmFtcCAobm90IGxpbmVhcikgZm9yIGEgbW9yZSBldmVuIGNyb3NzZmFkZVxuICAgIC8vIChsaW5lYXIgY3JlYXRlcyBhIHZvbHVtZSBkaXAgaW4gdGhlIG1pZGRsZSlcblxuICAgIGlmKHR5cGVvZiB0aGlzLm5vZGUuZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIHNldFRvID0gdS5ub3JtYWxpemUoc2V0VG8pXG4gICAgICBpZihzZXRUbyA9PT0gMCkgc2V0VG8gPSAwLjAwMDAwMSAvLyBjYW4ndCB1c2UgemVybyBmb3IgcmFtcHNcblxuICAgICAgdGhpcy5ub2RlLmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZShzZXRUbywgdGhpcy5jdHguY3VycmVudFRpbWUgKyBkdXJhdGlvbilcbiAgICB9XG4gIH1cblxuICBtdXRlZChzZXRUbyl7XG5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHYWluTm9kZSIsIi8qXG5cbiAgUGFuIE5vZGUgKDJEIC0gbGVmdC9yaWdodClcblxuKi9cblxuY2xhc3MgUGFubmVyTm9kZTJEIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKXtcbiAgICBsZXQgY3R4ID0gcGFyYW1zLmNvbnRleHRcblxuICAgIC8vIHRoZSBuYW1lIG9mIHRoaXMgZnVuY3Rpb24gaXMgdGhlIHNhbWUgZm9yXG4gICAgLy8gYm90aCBwcmVmaXhlZCBhbmQgdW5wcmVmaXhlZCBhdWRpbyBjb250ZXh0c1xuICAgIHRoaXMubm9kZSA9IGN0eC5jcmVhdGVQYW5uZXIoKVxuXG4gICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICBwYW46ICAwLFxuICAgICAgcGFuWDogMCxcbiAgICAgIHBhblk6IDAsXG4gICAgICBwYW5aOiAwLFxuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgc2V0dXAgaGVyZVxuICB9XG5cbiAgcGFuKGFuZ2xlKXtcblxuICAgIGlmKHR5cGVvZiBhbmdsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmKCAgICAgYW5nbGUgPT09ICdmcm9udCcpIGFuZ2xlID0gICAwO1xuICAgICAgZWxzZSBpZihhbmdsZSA9PT0gJ2JhY2snICkgYW5nbGUgPSAxODA7XG4gICAgICBlbHNlIGlmKGFuZ2xlID09PSAnbGVmdCcgKSBhbmdsZSA9IDI3MDtcbiAgICAgIGVsc2UgaWYoYW5nbGUgPT09ICdyaWdodCcpIGFuZ2xlID0gIDkwO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZiBhbmdsZSA9PT0gJ251bWJlcicpIHtcblxuICAgICAgdGhpcy52YWx1ZXMucGFuID0gYW5nbGUgJSAzNjA7XG5cbiAgICAgIHZhciBhbmdsZVJhZCA9ICgtYW5nbGUgKyA5MCkgKiAwLjAxNzQ1MzI5MjUxOTk0MzI5NTsgLy8gKiBQSS8xODBcblxuICAgICAgdmFyIHggPSB0aGlzLnZhbHVlcy5wYW5YID0gTWF0aC5jb3MoYW5nbGVSYWQpO1xuICAgICAgdmFyIHkgPSB0aGlzLnZhbHVlcy5wYW5ZID0gTWF0aC5zaW4oYW5nbGVSYWQpO1xuICAgICAgdmFyIHogPSB0aGlzLnZhbHVlcy5wYW5aID0gLTAuNTtcblxuICAgICAgdGhpcy5ub2RlLnNldFBvc2l0aW9uKHgsIHksIHopXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLnBhblxuICB9XG5cbiAgdHdlZW5QYW4oYW5nbGUsIGR1cmF0aW9uKXtcblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFubmVyTm9kZTJEIiwiLypcblxuICBQYW4gTm9kZSAoM0QpXG5cbiovXG5cbmNsYXNzIFBhbk5vZGUzRCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcyl7XG4gICAgbGV0IGN0eCA9IHBhcmFtcy5jb250ZXh0XG5cbiAgICAvLyB0aGUgbmFtZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBzYW1lIGZvclxuICAgIC8vIGJvdGggcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgYXVkaW8gY29udGV4dHNcbiAgICB0aGlzLm5vZGUgPSBjdHguY3JlYXRlUGFubmVyKClcblxuICAgIC8vIGFkZGl0aW9uYWwgc2V0dXAgaGVyZVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFuTm9kZTNEIiwiLypcblxuICBBbmFseXNlciBOb2RlIChGRlQpXG5cbiovXG5cbmNsYXNzIEFuYWx5c2VyTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcyl7XG4gICAgbGV0IGN0eCA9IHBhcmFtcy5jb250ZXh0XG5cbiAgICB0aGlzLm5vZGUgPSBjdHguY3JlYXRlQW5hbHlzZXIoKVxuXG4gICAgYW5hbHlzZXJOb2RlLnNtb290aGluZ1RpbWVDb25zdGFudCA9IDAuMlxuICAgIGFuYWx5c2VyTm9kZS5mZnRTaXplID0gMzJcblxuICAgIC8vIGNyZWF0ZSBhIHNjcmlwdCBwcm9jZXNzb3Igd2l0aCBidWZmZXJTaXplIG9mIDIwNDhcbiAgICB0aGlzLnByb2Nlc3NvciA9IGN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoMjA0OCwgMSwgMSlcblxuICAgIHByb2Nlc3Nvck5vZGUuY29ubmVjdChjdHguZGVzdGluYXRpb24pIC8vIHByb2Nlc3NvciAtPiBkZXN0aW5hdGlvblxuICAgIGFuYWx5c2VyTm9kZS5jb25uZWN0KHByb2Nlc3Nvck5vZGUpICAgIC8vIGFuYWx5c2VyICAtPiBwcm9jZXNzb3JcblxuICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gYW5hbHlzZXJOb2RlLmZyZXF1ZW5jeUJpbkNvdW50XG5cbiAgICB0aGlzLmFuYWx5c2lzID0ge1xuICAgICAgcmF3OiBuZXcgVWludDhBcnJheShvcHRpb25zLmJ1ZmZlckxlbmd0aCksXG4gICAgICBhdmVyYWdlOiAwLFxuICAgICAgbG93OiAgICAgMCxcbiAgICAgIG1pZDogICAgIDAsXG4gICAgICBoaWdoOiAgICAwLFxuICAgIH1cblxuICB9XG5cbiAgY29ubmVjdCh0byl7XG4gICAgdGhpcy5ub2RlLmNvbm5lY3QodG8pXG4gIH1cblxuICBnZXQoKXtcblxuICAgIGxldCB0aGlyZCA9IE1hdGgucm91bmQodGhpcy5idWZmZXJMZW5ndGggLyAzKVxuICAgIGxldCBzY3JhdGNoID0gMFxuICAgIGxldCBpID0gMFxuXG4gICAgdGhpcy5ub2RlLmdldEJ5dGVGcmVxdWVuY3lEYXRhKHRoaXMuYW5hbHlzaXMucmF3KVxuXG4gICAgLy8gY2FsY3VsYXRlIGF2ZXJhZ2UsIG1pZCwgaGlnaFxuICAgIHNjcmF0Y2ggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVyTGVuZ3RoOyBpKyspXG4gICAgICBzY3JhdGNoICs9IHRoaXMuYW5hbHlzaXMucmF3W2ldXG5cbiAgICB0aGlzLmFuYWx5c2lzLmF2ZXJhZ2UgPSAoc2NyYXRjaCAvIHRoaXMuYnVmZmVyTGVuZ3RoKSAvIDI1NlxuXG4gICAgLy8gbG93c1xuICAgIHNjcmF0Y2ggPSAwXG4gICAgZm9yIChpPTA7IGkgPCB0aGlyZDsgaSsrKVxuICAgICAgc2NyYXRjaCArPSB0aGlzLmFuYWx5c2lzLnJhd1tpXVxuXG4gICAgdGhpcy5hbmFseXNpcy5sb3cgPSBzY3JhdGNoIC8gdGhpcmQgLyAyNTZcblxuICAgIC8vIG1pZHNcbiAgICBzY3JhdGNoID0gMFxuICAgIGZvciAoaSA9IHRoaXJkOyBpIDwgdGhpcmQqMjsgaSsrKVxuICAgICAgc2NyYXRjaCArPSB0aGlzLmFuYWx5c2lzLnJhd1tpXVxuXG4gICAgdGhpcy5hbmFseXNpcy5taWQgPSBzY3JhdGNoIC8gdGhpcmQgLyAyNTZcblxuICAgIC8vIGhpZ2hzXG4gICAgc2NyYXRjaCA9IDBcbiAgICBmb3IgKGk9IHRoaXJkKjI7IGkgPCB0aGlzLmJ1ZmZlckxlbmd0aDsgaSsrKVxuICAgICAgc2NyYXRjaCArPSB0aGlzLmFuYWx5c2lzLnJhd1tpXVxuXG4gICAgdGhpcy5hbmFseXNpcy5oaWdoID0gc2NyYXRjaCAvIHRoaXJkIC8gMjU2XG5cbiAgICByZXR1cm4gdGhpcy5hbmFseXNpc1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuYWx5c2VyTm9kZVxuLy8gbW9kdWxlLmV4cG9ydHMgPSBBbmFseXNlck5vZGVcbiIsIi8qXG5cbiAgR2F0aGVyIGFsbCBub2RlcyBpbiBhIHNpbmdsZSBleHBvcnQuXG5cbiAgQWxsIG5vZGVzIG11c3QgaW1wbGVtZW50IHRoaXMgQVBJOlxuXG4gICAgbGV0IG4gPSBuZXcgTm9kZSh7XG4gICAgICBsYXN0Tm9kZTogTm9kZSxcbiAgICAgIGNvbnRleHQ6ICBXZWJBdWRpb0NvbnRleHQsXG4gICAgfSlcbiAgICBuLmNvbm5lY3QobGFzdE5vZGUpXG5cblxuICBpZVxuXG4gIGNsYXNzIE15Tm9kZSB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKXtcbiAgICAgIGxldCBjdHggPSBwYXJhbXMuY29udGV4dFxuICAgICAgdGhpcy5teU5vZGUgPSBjdHguY3JlYXRlTm9kZVR5cGUgPyBjdHguY3JlYXRlTm9kZVR5cGUoKSA6IGN0eC5jcmVhdGVUeXBlKClcblxuICAgICAgLy8gYWRkaXRpb25hbCBzZXR1cCBoZXJlXG4gICAgfVxuXG4gICAgY29ubmVjdChwcmV2aW91c05vZGUpe1xuICAgICAgcHJldmlvdXNOb2RlLmNvbm5lY3QodGhpcy5teU5vZGUpXG4gICAgICByZXR1cm4gdGhpcy5teU5vZGVcbiAgICB9XG4gIH1cblxuKi9cbmltcG9ydCBHYWluTm9kZSBmcm9tICcuL0dhaW5Ob2RlJ1xuaW1wb3J0IFBhbm5lck5vZGUyRCBmcm9tICcuL1Bhbm5lck5vZGUyRCdcbmltcG9ydCBQYW5uZXJOb2RlIGZyb20gJy4vUGFubmVyTm9kZSdcbmltcG9ydCBBbmFseXNlck5vZGUgZnJvbSAnLi9BbmFseXNlck5vZGUnXG5cbmV4cG9ydCBkZWZhdWx0IHsgR2Fpbk5vZGUsIFBhbm5lck5vZGUyRCwgUGFubmVyTm9kZSwgQW5hbHlzZXJOb2RlIH1cbiIsIi8qXG5cbiAgV2ViIEF1ZGlvIEFQSSB0cmFjayAtIHRvIGJlIGV4dGVuZGVkXG5cbiAgICBhZGRzIG5vZGUgZnVuY3Rpb25hbGl0eSB0byBiYXNlIHRyYWNrXG5cbiovXG5pbXBvcnQgQmFzZVRyYWNrIGZyb20gJy4vQmFzZVRyYWNrJ1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnXG5cbmltcG9ydCBOb2RlcyBmcm9tICcuL25vZGVzL2FsbE5vZGVzJ1xuXG5jbGFzcyBXZWJBdWRpb1RyYWNrIGV4dGVuZHMgQmFzZVRyYWNrIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKXtcbiAgICBzdXBlcihwYXJhbXMpXG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgbGV0IGRlZmF1bHRzID0ge1xuICAgICAgc3JjOiAgICAgICcnLFxuICAgICAgY29udGV4dDogIGZhbHNlLFxuICAgICAgbm9kZXM6ICAgIFtdLFxuICAgIH1cbiAgICB0cmFjay5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgcGFyYW1zKVxuXG4gICAgdHJhY2suZGF0YSA9IHt9XG5cbiAgICAvLyByZWZlcmVuY2Ugbm9kZXMgYnkgPz8/XG4gICAgdHJhY2suYWxsTm9kZXMgICA9IFtdXG4gICAgdHJhY2subm9kZUxvb2t1cCA9IHt9XG4gIH1cblxuXG4gIC8qXG5cbiAgICBpbnB1dCBpcyBhbiBhcnJheVxuXG4gICovXG4gIGNyZWF0ZU5vZGVzKG5vZGVzLCBzb3VyY2Upe1xuICAgIGxldCB0cmFjayA9IHRoaXNcblxuICAgIGlmKCFzb3VyY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW7igJl0IGNyZWF0ZSBub2RlcyB3aXRob3V0IGEgdmFsaWQgc291cmNlLicpXG4gICAgfSBlbHNlIGlmKCFzb3VyY2UuY29ubmVjdCl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbuKAmXQgY3JlYXRlIG5vZGVzIHdpdGhvdXQgYSB2YWxpZCBzb3VyY2UuJylcbiAgICB9XG5cbiAgICAvLyBjbGVhciBwcmV2aW91cyBzZXQgb2Ygbm9kZXMgKHdlIHJlY3JlYXRlIG5vZGVzIGV2ZXJ5IHRpbWUgd2UgcGxheSlcbiAgICB0cmFjay5hbGxOb2RlcyA9IFtdXG5cbiAgICBsZXQgcHJldmlvdXNOb2RlID0gc291cmNlXG4gICAgbm9kZXMuZm9yRWFjaChuID0+IHtcblxuICAgICAgbGV0IGJhc2VQYXJhbXMgPSB7XG4gICAgICAgIGNvbnRleHQ6IHRyYWNrLm9wdGlvbnMuY29udGV4dFxuICAgICAgfVxuXG4gICAgICAvLyBkZXRlcm1pbmUgbm9kZSB0eXBlIGJ5IGR1Y2sgdHlwaW5nXG4gICAgICBpZih0eXBlb2YgbiA9PT0gJ3N0cmluZycpe1xuICAgICAgICAvLyBwcmVkZWZpbmVkIG5vZGUgd2l0aCBhbGwgZGVmYXVsdHMsIG5vIG9wdGlvbnNcblxuICAgICAgICBpZihOb2Rlc1tuXSl7XG5cbiAgICAgICAgICBsZXQgbmV3Tm9kZSA9IG5ldyBOb2Rlc1tuXShiYXNlUGFyYW1zKVxuICAgICAgICAgIHRyYWNrLmFsbE5vZGVzLnB1c2gobmV3Tm9kZSlcbiAgICAgICAgICB0cmFjay5ub2RlTG9va3VwW25dID0gbmV3Tm9kZVxuXG4gICAgICAgICAgcHJldmlvdXNOb2RlLmNvbm5lY3QobmV3Tm9kZS5ub2RlKVxuICAgICAgICAgIHByZXZpb3VzTm9kZSA9IG5ld05vZGUubm9kZVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIHR5cGUgJHtufSBkb2VzIG5vdCBleGlzdC5gKVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgbiA9PT0gJ29iamVjdCcpe1xuICAgICAgICBpZiggbi50eXBlICl7XG4gICAgICAgICAgLy8gY3JlYXRlIHByZWRlZmluZWQgbm9kZSB3aXRoIG9wdGlvbnNcbiAgICAgICAgICBsZXQgbm9kZVR5cGUgPSBOb2Rlc1tuLnR5cGVdXG5cbiAgICAgICAgICBpZihub2RlVHlwZSl7XG4gICAgICAgICAgICBsZXQgbmV3Tm9kZSA9IG5ldyBub2RlVHlwZSggT2JqZWN0LmFzc2lnbihiYXNlUGFyYW1zLCBuLm9wdGlvbnMpIClcblxuICAgICAgICAgICAgdHJhY2suYWxsTm9kZXMucHVzaChuZXdOb2RlKVxuICAgICAgICAgICAgdHJhY2subm9kZUxvb2t1cFtuLnR5cGVdID0gbmV3Tm9kZVxuXG4gICAgICAgICAgICBwcmV2aW91c05vZGUuY29ubmVjdChuZXdOb2RlLm5vZGUpXG4gICAgICAgICAgICBwcmV2aW91c05vZGUgPSBuZXdOb2RlLm5vZGVcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgdHlwZSAke24udHlwZX0gZG9lcyBub3QgZXhpc3QuYClcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmKG4ubm9kZSkge1xuICAgICAgICAgIC8vIGNyZWF0ZSBjdXN0b20gbm9kZSwgdGhpcyBpcyBhIHJhdyBub2RlIG9iamVjdFxuXG4gICAgICAgICAgdHJhY2suYWxsTm9kZXMucHVzaChuKVxuXG4gICAgICAgICAgcHJldmlvdXNOb2RlLmNvbm5lY3Qobi5ub2RlKVxuICAgICAgICAgIHByZXZpb3VzTm9kZSA9IG4ubm9kZVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pXG5cbiAgICBwcmV2aW91c05vZGUuY29ubmVjdCh0cmFjay5vcHRpb25zLmNvbnRleHQuZGVzdGluYXRpb24pXG5cbiAgfVxuXG4gIG5vZGVzKCl7XG4gICAgcmV0dXJuIHRoaXMuYWxsTm9kZXNcbiAgfVxuXG4gIG5vZGUoaWQpe1xuICAgIHJldHVybiB0aGlzLm5vZGVMb29rdXBbaWRdIHx8IGZhbHNlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJBdWRpb1RyYWNrXG4iLCIvKlxuXG4gIFdlYiBBdWRpbyBBUEk6IEJ1ZmZlciBTb3VyY2UgdHJhY2tcblxuKi9cbmltcG9ydCBXZWJBdWRpb1RyYWNrIGZyb20gJy4vV2ViQXVkaW9UcmFjaydcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJ1xuXG5pbXBvcnQgbm9kZXMgZnJvbSAnLi9ub2Rlcy9hbGxOb2RlcydcblxuY2xhc3MgQnVmZmVyU291cmNlVHJhY2sgZXh0ZW5kcyBXZWJBdWRpb1RyYWNrIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKXtcbiAgICBzdXBlcihwYXJhbXMpXG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgbGV0IGRlZmF1bHRzID0ge1xuICAgICAgaWQ6ICAgICAgICcnLFxuICAgICAgc3JjOiAgICAgICcnLFxuICAgICAgdm9sdW1lOiAgIDEsXG4gICAgICBzdGFydDogICAgMCxcbiAgICAgIGxvb3A6ICAgICBmYWxzZSxcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIGF1dG9sb2FkOiB0cnVlLFxuICAgICAgY29udGV4dDogIGZhbHNlLFxuICAgICAgbWl4OiAgICAgIGZhbHNlLFxuICAgICAgbm9kZXM6ICAgIFtdLFxuICAgIH1cblxuICAgIHRyYWNrLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBwYXJhbXMpXG5cbiAgICB0cmFjay5zdGF0dXMgPSB7XG4gICAgICByZWFkeTogZmFsc2UsXG4gICAgICBzaG91bGRQbGF5T25Mb2FkOiBmYWxzZSxcblxuICAgICAgcGxheWluZzogIGZhbHNlLFxuICAgICAgbXV0ZWQ6ICAgIHRyYWNrLm9wdGlvbnMubXV0ZWQgfHwgZmFsc2UsXG4gICAgfVxuXG4gICAgLy8gaW50ZXJuYWwgZmxhZ3MgYW5kIGRhdGFcbiAgICB0cmFjay5kYXRhID0ge1xuICAgICAgZ2FpbjogdHJhY2sub3B0aW9ucy52b2x1bWUsXG5cbiAgICAgIC8vIG1hbnVhbCB0aW1lIHRyYWNraW5nXG4gICAgICBjYWNoZWRUaW1lOiAwLFxuICAgICAgc3RhcnRUaW1lOiAgMCxcbiAgICB9XG5cbiAgICBpZighdHJhY2sub3B0aW9ucy5jb250ZXh0KXtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fu4oCZdCBjcmVhdGUgYSBXZWJBdWRpb1RyYWNrIHdpdGhvdXQgV2ViIEF1ZGlvIEFQSSBzdXBwb3J0JylcbiAgICB9XG5cbiAgICBpZighdHJhY2sub3B0aW9ucy5zcmMpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW7igJl0IGNyZWF0ZSBhIFdlYkF1ZGlvVHJhY2sgd2l0aG91dCBhIHNyYyBwYXJhbWV0ZXInKVxuICAgIH1cblxuICAgIC8vIGxpbWl0ZWQgc3Vic2V0IG9mIGV2ZW50cyBhdmFpbGFibGUgYmVjYXVzZSB0aGV5J3JlIGFsbCBzaW11bGF0ZWRcbiAgICBsZXQgZXZlbnROYW1lcyA9IFtcbiAgICAgICdsb2Fkc3RhcnQnLCAnbG9hZGVkbWV0YWRhdGEnLFxuICAgICAgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLFxuICAgICAgJ3BsYXknLCAncGF1c2UnLFxuICAgICAgJ2VuZGVkJyxcbiAgICAgICdlcnJvcicsXG4gICAgXVxuXG4gICAgLy8gbG9hZCB0aGUgc291cmNlIHRoZSByaWdodCBhd2F5LCBldmVuIGlmIGF1dG9wbGF5IGlzbid0IHNldC5cbiAgICBpZih0cmFjay5vcHRpb25zLmF1dG9sb2FkIHx8IHRyYWNrLm9wdGlvbnMuYXV0b3BsYXkpe1xuICAgICAgdHJhY2subG9hZCgpXG4gICAgfVxuXG4gIH1cblxuICAvKlxuXG4gICAgUGxheWJhY2sgbmVlZHMgdG8gd2FpdCBmb3IgdGhlIHRyYWNrIHRvIGJlIGxvYWRlZC5cbiAgICBBZnRlciB0aGlzLCBpdCdzIGEgc3luY2hyb25vdXMgZnVuY3Rpb24uXG5cbiAgICBZb3UgY2FuIGxpc3RlbiBmb3IgdGhlICdjYW5wbGF5dGhyb3VnaCcgZXZlbnQgdG8gZW5zdXJlXG4gICAgc3luY2hyb25vdXMgcGxheWJhY2sgb2YgbXVsdGlwbGUgYnVmZmVyIHRyYWNrcy5cblxuICAqL1xuICBwbGF5KCl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgLy8gdGhpcyBsb2dpYyBhY2NvbW9kYXRlcyBjYWxsaW5nIHBsYXkoKSBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSB0cmFjayB0byBiZSBzZXQgdXBcblxuICAgIGlmKHRyYWNrLnN0YXR1cy5wbGF5aW5nKVxuICAgICAgcmV0dXJuIHRyYWNrXG5cbiAgICBpZighdHJhY2suc3RhdHVzLnJlYWR5KXtcblxuICAgICAgaWYoIXRyYWNrLm9wdGlvbnMuYXV0b2xvYWQgJiYgIXRyYWNrLnN0YXR1cy5zaG91bGRQbGF5T25Mb2FkKXtcbiAgICAgICAgdHJhY2subG9hZCgpXG4gICAgICB9XG5cbiAgICAgIHRyYWNrLnN0YXR1cy5zaG91bGRQbGF5T25Mb2FkID0gdHJ1ZVxuXG4gICAgICByZXR1cm4gdHJhY2tcbiAgICB9XG5cbiAgICAvKlxuXG4gICAgICBpZiB3ZSBnb3QgdGhpcyBmYXIgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gcGxheSwgbGV0J3MgZ28hXG5cbiAgICAqL1xuXG4gICAgbGV0IGN0eCA9IHRyYWNrLm9wdGlvbnMuY29udGV4dFxuXG4gICAgLy8gdGhlIGJ1ZmZlciBuZWVkcyB0byBiZSByZS1jcmVhdGVkIGV2ZXJ5IHRpbWUgd2UgcGxheSgpXG4gICAgdHJhY2suZGF0YS5zb3VyY2UgPSBjdHguY3JlYXRlQnVmZmVyU291cmNlKClcbiAgICB0cmFjay5kYXRhLnNvdXJjZS5idWZmZXIgPSB0cmFjay5kYXRhLmRlY29kZWRCdWZmZXJcblxuICAgIC8vIHRyYWNrLmRhdGEuc291cmNlLmxvb3AgPSAodHJhY2sub3B0aW9ucy5sb29wKSA/IHRydWUgOiBmYWxzZVxuXG4gICAgLy8gYXMgZG8gdGhlIG5vZGVzXG4gICAgbGV0IGdhaW5Ob2RlID0geyB0eXBlOiAnR2Fpbk5vZGUnLCBvcHRpb25zOiB7IGdhaW46IHRyYWNrLmRhdGEuZ2FpbiB9IH1cbiAgICBzdXBlci5jcmVhdGVOb2RlcyhbZ2Fpbk5vZGUsIC4uLnRyYWNrLm9wdGlvbnMubm9kZXNdLCB0cmFjay5kYXRhLnNvdXJjZSlcblxuICAgIHRyYWNrLmRhdGEuc3RhcnRUaW1lID0gdHJhY2suZGF0YS5zb3VyY2UuY29udGV4dC5jdXJyZW50VGltZSAtIHRyYWNrLmRhdGEuY2FjaGVkVGltZVxuICAgIHZhciBzdGFydEZyb20gPSB0cmFjay5kYXRhLmNhY2hlZFRpbWUgfHwgMFxuXG4gICAgLy8gcHJlZmVyIHN0YXJ0KCkgYnV0IGZhbGwgYmFjayB0byBvbGRlciwgZGVwcmVjYXRlZCBub3RlT24oKVxuICAgIGlmKHR5cGVvZiB0cmFjay5kYXRhLnNvdXJjZS5zdGFydCA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICB0cmFjay5kYXRhLnNvdXJjZS5zdGFydCgwLCBzdGFydEZyb20pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrLmRhdGEuc291cmNlLm5vdGVPbihzdGFydEZyb20pXG4gICAgfVxuXG4gICAgdHJhY2suc2V0RW5kVGltZXIoKVxuXG4gICAgdHJhY2suc3RhdHVzLnBsYXlpbmcgPSB0cnVlXG4gICAgc3VwZXIudHJpZ2dlcigncGxheScsIHRyYWNrKVxuXG4gICAgcmV0dXJuIHRyYWNrXG5cbiAgfVxuXG4gIC8qXG5cbiAgICBCdWZmZXIgc291cmNlIG1vZGUgcmVxdWlyZXMgdGhlIHNvdXJjZSBmaWxlIHRvIGJlIGZ1bGx5IGxvYWRlZFxuICAgIGFuZCBkZWNvZGVkIGJlZm9yZSBpdCBjYW4gYmUgcGxheSwgc28gaGVyZSB3ZSBmZXRjaCBpdCBhcyBhblxuICAgIGFycmF5IGJ1ZmZlciAoYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBpbiByYXcgYmluYXJ5IGZvcm1hdCB0byBiZVxuICAgIGRlY29kZWQpLlxuXG4gICAgV2ViIEF1ZGlvIEFQSSBoYXMgdGhlIHNhbWUgYnJvd3NlciBzdXBwb3J0IGFzIGZldGNoIChubyBJRSxcbiAgICBub3QgZXZlbiAxMSksIHNvIHdlIGNhbiB1c2UgdGhpcyBkZWxpZ2h0ZnVsIG1ldGhvZC5cblxuICAqL1xuICBsb2FkKCl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuICAgIGxldCBjdHggPSB0cmFjay5vcHRpb25zLmNvbnRleHRcblxuICAgIHN1cGVyLnRyaWdnZXIoJ2xvYWRzdGFydCcpXG5cbiAgICByZXR1cm4gd2luZG93LmZldGNoKHRyYWNrLm9wdGlvbnMuc3JjKVxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5hcnJheUJ1ZmZlcigpKVxuICAgICAgLnRoZW4oYXVkaW9EYXRhID0+IHtcbiAgICAgICAgdHJhY2suZGF0YS5hdWRpb0RhdGEgPSBhdWRpb0RhdGFcblxuICAgICAgICAvLyBEZWNvZGUgYXVkaW8gZGF0YVxuICAgICAgICBpZih0eXBlb2YgY3R4LmNyZWF0ZUdhaW4gPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgIC8vIFczQyBzdGFuZGFyZCBpbXBsZW1lbnRhdGlvbiAtIGFzeW5jIChGaXJlZm94LCByZWNlbnQgQ2hyb21lKVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgICAgY3R4LmRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEsIGZ1bmN0aW9uKGRlY29kZWRCdWZmZXIpe1xuICAgICAgICAgICAgICB0cmFjay5kYXRhLmRlY29kZWRCdWZmZXIgPSBkZWNvZGVkQnVmZmVyXG4gICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgY3R4LmNyZWF0ZUdhaW5Ob2RlID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAvLyBOb24tc3RhbmRhcmQgV2Via2l0IGltcGxlbWVudGF0aW9uIChTYWZhcmksIG9sZCBDaHJvbWUpXG4gICAgICAgICAgLy8gbm90IGFzeW5jIGJ1dCB3ZSBmYWtlIGl0IGZvciBjb25zaXN0ZW5jeVxuICAgICAgICAgIGxldCBkZWNvZGVkQnVmZmVyID0gY3R4LmNyZWF0ZUJ1ZmZlcihhdWRpb0RhdGEsIHRydWUpXG4gICAgICAgICAgdHJhY2suZGF0YS5kZWNvZGVkQnVmZmVyID0gZGVjb2RlZEJ1ZmZlclxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9XG5cbiAgICAgIH0pXG5cbiAgICAgIC50aGVuKCgpID0+IHtcblxuICAgICAgICB0cmFjay5zdGF0dXMucmVhZHkgPSB0cnVlXG5cbiAgICAgICAgLy8gbm93IHRoYXQgdGhlIHNvdXJjZSBpcyBkZWNvZGVkLCB3ZSBrbm93IGl0cyBkdXJhdGlvblxuICAgICAgICBzdXBlci50cmlnZ2VyKCdsb2FkZWRtZXRhZGF0YScpXG4gICAgICAgIHN1cGVyLnRyaWdnZXIoJ2NhbnBsYXknKVxuICAgICAgICBzdXBlci50cmlnZ2VyKCdjYW5wbGF5dGhyb3VnaCcpXG5cbiAgICAgICAgaWYodHJhY2sub3B0aW9ucy5hdXRvcGxheSB8fCB0cmFjay5zdGF0dXMuc2hvdWxkUGxheU9uTG9hZCl7XG4gICAgICAgICAgdHJhY2sucGxheSgpXG4gICAgICAgIH1cblxuICAgICAgfSlcbiAgfVxuXG5cblxuICAvKlxuXG4gICAgQnVmZmVyIHRyYWNrcyBkb24ndCBoYXZlIGFuIGVuZGVkIGV2ZW50IHNvIHdlIHNpbXVsYXRlIGl0IHVzaW5nIHNldFRpbWVvdXRcblxuICAqL1xuXG4gIHNldEVuZFRpbWVyKCl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuICAgIGxldCBzdGFydEZyb20gPSB0cmFjay5kYXRhLmNhY2hlZFRpbWUgfHwgMFxuICAgIHRyYWNrLmRhdGEudGltZXJEdXJhdGlvbiA9ICh0cmFjay5kYXRhLnNvdXJjZS5idWZmZXIuZHVyYXRpb24gLSBzdGFydEZyb20pXG5cbiAgICBpZih0cmFjay5kYXRhLm9uZW5kdGltZXIpe1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0cmFjay5kYXRhLm9uZW5kdGltZXIpXG4gICAgfVxuXG4gICAgdHJhY2suZGF0YS5vbmVuZHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQodHJhY2suZW5kZWQuYmluZCh0cmFjayksIHRyYWNrLmRhdGEudGltZXJEdXJhdGlvbiAqIDEwMDApXG4gIH1cblxuICBlbmRlZCgpIHtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG4gICAgaWYodHJhY2sub3B0aW9ucy5sb29wKXtcbiAgICAgIHN1cGVyLnRyaWdnZXIoJ2VuZGVkJywgdHJhY2spXG4gICAgICBzdXBlci50cmlnZ2VyKCdsb29wJywgdHJhY2spXG4gICAgICB0cmFjay5wYXVzZSgwKVxuICAgICAgdHJhY2sucGxheSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrLnN0YXR1cy5wbGF5aW5nID0gZmFsc2VcbiAgICAgIHN1cGVyLnRyaWdnZXIoJ2VuZGVkJywgdHJhY2spXG4gICAgfVxuICB9XG5cblxuXG4gIC8vIGVuZCBvZiBwbGF5IGZ1bmN0aW9uc1xuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cblxuXG5cblxuICBwYXVzZShwYXVzZUF0VGltZSl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgLy8gZGlzYWJsZSBhdXRvcGxheSwgaWYgd2UndmUgcGF1c2VkIHRoZSB0cmFjayBiZWZvcmUgaXQncyBoYWQgYSBjaGFuY2UgdG8gbG9hZFxuICAgIGlmKCF0cmFjay5zdGF0dXMucGxheWluZyAmJiB0cmFjay5zdGF0dXMuc2hvdWxkUGxheU9uTG9hZCl7XG4gICAgICB0cmFjay5zdGF0dXMuc2hvdWxkUGxheU9uTG9hZCA9IGZhbHNlXG4gICAgICB0cmFjay5vcHRpb25zLmF1dG9wbGF5ID0gZmFsc2VcbiAgICAgIHJldHVybiB0cmFja1xuICAgIH1cblxuICAgIHRyYWNrLmRhdGEuY2FjaGVkVGltZSA9ICh0eXBlb2YgcGF1c2VBdFRpbWUgPT09ICdudW1iZXInID8gcGF1c2VBdFRpbWUgOiB0cmFjay5jdXJyZW50VGltZSgpKVxuXG4gICAgdHJhY2suc3RhdHVzLnBsYXlpbmcgPSBmYWxzZVxuXG4gICAgaWYodHJhY2suZGF0YS5vbmVuZHRpbWVyKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRyYWNrLmRhdGEub25lbmR0aW1lcilcblxuICAgIC8vIHByZWZlciBzdG9wKCksIGZhbGxiYWNrIHRvIGRlcHJlY2F0ZWQgbm90ZU9mZigpXG4gICAgaWYodHlwZW9mIHRyYWNrLmRhdGEuc291cmNlLnN0b3AgPT09ICdmdW5jdGlvbicpXG4gICAgICB0cmFjay5kYXRhLnNvdXJjZS5zdG9wKDApXG4gICAgZWxzZSBpZih0eXBlb2YgdHJhY2suZGF0YS5zb3VyY2Uubm90ZU9mZiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRyYWNrLmRhdGEuc291cmNlLm5vdGVPZmYoMClcblxuICAgIHN1cGVyLnRyaWdnZXIoJ3BhdXNlJywgdHJhY2spXG5cbiAgICByZXR1cm4gdHJhY2tcbiAgfVxuXG4gIGN1cnJlbnRUaW1lKHNldFRvKSB7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgaWYodHlwZW9mIHNldFRvID09PSAnbnVtYmVyJykge1xuXG4gICAgICBpZih0cmFjay5zdGF0dXMucGxheWluZykge1xuICAgICAgICAvLyB0byBzZWVrIGEgYnVmZmVyIHRyYWNrLCB3ZSBuZWVkIHRvIHBhdXNlIGFuZCBwbGF5XG4gICAgICAgIHRyYWNrLnBhdXNlKHNldFRvKS5wbGF5KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIHBhdXNlZCBvciBub3QgbG9hZGVkIHlldCwgY2FjaGUgdGhlIHRpbWVcbiAgICAgICAgdHJhY2suZGF0YS5jYWNoZWRUaW1lID0gc2V0VG9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYWNrXG4gICAgfVxuXG4gICAgaWYoIXRyYWNrLnN0YXR1cy5yZWFkeSB8fCAhdHJhY2suc3RhdHVzLnBsYXlpbmcpXG4gICAgICByZXR1cm4gdHJhY2suZGF0YS5jYWNoZWRUaW1lIHx8IDBcblxuICAgIHJldHVybiAodHJhY2suZGF0YS5zb3VyY2UuY29udGV4dC5jdXJyZW50VGltZSAtIHRyYWNrLmRhdGEuc3RhcnRUaW1lKSB8fCAwXG5cbiAgfVxuXG4gIGZvcm1hdHRlZFRpbWUoaW5jbHVkZUR1cmF0aW9uKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG4gICAgaWYoaW5jbHVkZUR1cmF0aW9uKVxuICAgICAgcmV0dXJuIHV0aWxzLnRpbWVGb3JtYXQodHJhY2suY3VycmVudFRpbWUoKSkgKyAnLycgKyB1dGlscy50aW1lRm9ybWF0KHRyYWNrLmR1cmF0aW9uKCkpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB1dGlscy50aW1lRm9ybWF0KHRyYWNrLmN1cnJlbnRUaW1lKCkpO1xuICB9XG5cbiAgZHVyYXRpb24oKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG5cbiAgICBpZighdHJhY2suc3RhdHVzLnJlYWR5KXsgcmV0dXJuIDAgfVxuXG4gICAgcmV0dXJuIHRyYWNrLmRhdGEuc291cmNlLmJ1ZmZlci5kdXJhdGlvbiB8fCAwXG4gIH1cblxuICAvLyBmb3IgYSBidWZmZXIgdHJhY2ssIHZvbHVtZSgpIGlzIGJhc2ljYWxseSBhbiBhbGlhcyBmb3IgdGhlIGdhaW4gbm9kZVxuICB2b2x1bWUoc2V0VG8pe1xuICAgIGxldCB0cmFjayA9IHRoaXNcbiAgICBsZXQgZ2Fpbk5vZGUgPSB0cmFjay5ub2RlKCdHYWluTm9kZScpXG5cbiAgICBpZih0eXBlb2Ygc2V0VG8gPT09ICdudW1iZXInKSB7XG4gICAgICBzZXRUbyA9IHV0aWxzLm5vcm1hbGl6ZShzZXRUbylcblxuICAgICAgaWYodHJhY2suc3RhdHVzLm11dGVkKSB7XG4gICAgICAgIHRyYWNrLmRhdGEuZ2FpbkNhY2hlID0gc2V0VG8gLy8gY2FjaGUgdGhlIHZhbHVlIGZvciB3aGVuIHdlIHVubXV0ZVxuICAgICAgICB0cmFjay5kYXRhLmdhaW4gPSAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFjay5kYXRhLmdhaW4gPSBzZXRUb1xuICAgICAgfVxuXG4gICAgICBpZih0cmFjay5zdGF0dXMucGxheWluZyl7XG4gICAgICAgIGlmKGdhaW5Ob2RlKVxuICAgICAgICAgIGdhaW5Ob2RlLmdhaW4odHJhY2sub3B0aW9ucy5taXggPyB0cmFjay5kYXRhLmdhaW4gKiB0cmFjay5vcHRpb25zLm1peC52b2x1bWUoKSA6IHRyYWNrLmRhdGEuZ2FpbilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYWNrXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gYWNjdXJhdGVseSByZXBvcnQgZ2FpbiB3aGlsZSB3ZeKAmXJlIHR3ZWVuaW5nIGl0XG4gICAgICBpZih0cmFjay5zdGF0dXMucGxheWluZylcbiAgICAgICAgaWYoZ2Fpbk5vZGUpXG4gICAgICAgICAgdHJhY2suZGF0YS5nYWluID0gZ2Fpbk5vZGUuZ2FpbigpXG5cbiAgICAgIHJldHVybiB0cmFjay5kYXRhLmdhaW47XG5cbiAgICB9XG5cbiAgfVxuXG4gIHR3ZWVuVm9sdW1lKHNldFRvLCBkdXJhdGlvbil7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIHZvbHVtZSB0d2VlblxuICAgIGlmKHRyYWNrLnZvbHVtZVR3ZWVuKXtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0cmFjay52b2x1bWVUd2VlbilcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nLCB3ZSBjYW4gdXNlIHRoZSBnYWluIG5vZGUncyBuYXRpdmUgdmFsdWUgcmFtcCBtZXRob2RcbiAgICBsZXQgZ2Fpbk5vZGUgPSB0cmFjay5ub2RlKCdHYWluTm9kZScpXG4gICAgaWYoZ2Fpbk5vZGUpe1xuICAgICAgZ2Fpbk5vZGUudHdlZW5HYWluKHNldFRvLCBkdXJhdGlvbilcbiAgICAgIHJldHVybiB1LnRpbWVvdXRQcm9taXNlKGR1cmF0aW9uICogMTAwMClcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBub3QgcGxheWluZyBvciBoYXZlbid0IGxvYWRlZCB5ZXQsXG4gICAgLy8gZmFsbCBiYWNrIHRvIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuXG4gICAgICBsZXQgZnBzID0gNjAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICBsZXQgZHVyYXRpb25JbkZyYW1lcyA9IE1hdGgucm91bmQoZHVyYXRpb24gKiBmcHMpXG4gICAgICBsZXQgZnJhbWVDb3VudCAgICAgICA9IE1hdGgucm91bmQoZHVyYXRpb24gKiBmcHMpXG4gICAgICBsZXQgc3RhcnRWb2x1bWUgICAgICA9IHRyYWNrLnZvbHVtZSgpXG4gICAgICBsZXQgZW5kVm9sdW1lICAgICAgICA9IHV0aWxzLm5vcm1hbGl6ZShzZXRUbylcblxuICAgICAgdGljaygpXG5cbiAgICAgIGZ1bmN0aW9uIHRpY2soKXtcbiAgICAgICAgaWYoZnJhbWVDb3VudCA8PSAwKXtcbiAgICAgICAgICB0cmFjay52b2x1bWUoZW5kVm9sdW1lKVxuICAgICAgICAgIHJlc29sdmUodHJhY2spXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhY2sudm9sdW1lVHdlZW4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spXG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZUNvdW50IC09IDFcbiAgICAgICAgbGV0IHByb2dyZXNzID0gKDEgLSAoZnJhbWVDb3VudCAvIGR1cmF0aW9uSW5GcmFtZXMpKVxuICAgICAgICBsZXQgdiA9IHV0aWxzLmxlcnAoc3RhcnRWb2x1bWUsIGVuZFZvbHVtZSwgcHJvZ3Jlc3MpXG4gICAgICAgIHRyYWNrLnZvbHVtZSggdiApXG4gICAgICB9XG5cbiAgICB9KVxuXG5cbiAgfVxuXG4gIG11dGVkKHNldFRvKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG5cbiAgICBpZih0eXBlb2Ygc2V0VG8gPT09ICdib29sZWFuJyl7XG4gICAgICBpZihzZXRUbyA9PT0gdHJ1ZSl7XG5cbiAgICAgICAgLy8gbXV0ZTogY2FjaGUgY3VycmVudCBnYWluLCB0aGVuIHNldCB0byAwXG4gICAgICAgIHRyYWNrLmRhdGEuZ2FpbkNhY2hlID0gdHJhY2suZGF0YS5nYWluXG4gICAgICAgIHRyYWNrLnZvbHVtZSgwKVxuICAgICAgICB0cmFjay5zdGF0dXMubXV0ZWQgPSB0cnVlXG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gdW5tdXRlXG4gICAgICAgIHRyYWNrLnN0YXR1cy5tdXRlZCA9IGZhbHNlXG4gICAgICAgIHRyYWNrLnZvbHVtZSh0cmFjay5kYXRhLmdhaW5DYWNoZSlcblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrLnN0YXR1cy5tdXRlZFxuICB9XG5cbiAgcGF1c2VkKCl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuICAgIHJldHVybiAhdHJhY2suc3RhdHVzLnBsYXlpbmdcbiAgfVxuXG4gIGRlc3Ryb3koKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG5cbiAgICB0cmFjay5wYXVzZSgpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJTb3VyY2VUcmFja1xuIiwiLypcblxuICBXZWIgQXVkaW8gQVBJOiBFbGVtZW50IFNvdXJjZSB0cmFja1xuXG4qL1xuaW1wb3J0IFdlYkF1ZGlvVHJhY2sgZnJvbSAnLi9XZWJBdWRpb1RyYWNrJ1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnXG5cbmltcG9ydCBub2RlcyBmcm9tICcuL25vZGVzL2FsbE5vZGVzJ1xuXG5jbGFzcyBFbGVtZW50U291cmNlVHJhY2sgZXh0ZW5kcyBXZWJBdWRpb1RyYWNrIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKXtcbiAgICBzdXBlcihwYXJhbXMpXG4gICAgbGV0IHRyYWNrID0gdGhpc1xuXG4gICAgbGV0IGRlZmF1bHRzID0ge1xuICAgICAgaWQ6ICAgICAgICcnLFxuICAgICAgc3JjOiAgICAgICcnLFxuICAgICAgdm9sdW1lOiAgIDEsXG4gICAgICBzdGFydDogICAgMCxcbiAgICAgIGxvb3A6ICAgICBmYWxzZSxcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIGNvbnRleHQ6ICBmYWxzZSxcbiAgICAgIG1peDogICAgICBmYWxzZSxcbiAgICAgIG5vZGVzOiAgICBbXSxcbiAgICB9XG5cbiAgICB0cmFjay5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgcGFyYW1zKVxuXG4gICAgaWYoIXRyYWNrLm9wdGlvbnMuY29udGV4dCl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbuKAmXQgY3JlYXRlIGFuIEVsZW1lbnRTb3VyY2VUcmFjayB3aXRob3V0IFdlYiBBdWRpbyBBUEkgc3VwcG9ydCcpXG4gICAgfVxuXG4gICAgLy8gc2V0IHVwIG91ciBIVE1MNSA8YXVkaW8+IGVsZW1lbnRcbiAgICBpZighdHJhY2sub3B0aW9ucy5zcmMpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW7igJl0IGNyZWF0ZSBhbiBFbGVtZW50U291cmNlVHJhY2sgd2l0aG91dCBhIHNyYyBwYXJhbWV0ZXInKVxuICAgIH1cblxuICAgIHRyYWNrLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKVxuXG4gICAgdHJhY2suZWwudm9sdW1lICAgPSB0cmFjay5vcHRpb25zLnZvbHVtZVxuICAgIHRyYWNrLmVsLm11dGVkICAgID0gdHJhY2sub3B0aW9ucy5tdXRlZFxuICAgIHRyYWNrLmVsLmxvb3AgICAgID0gdHJhY2sub3B0aW9ucy5sb29wXG4gICAgdHJhY2suZWwuYXV0b3BsYXkgPSB0cmFjay5vcHRpb25zLmF1dG9wbGF5XG5cbiAgICB0cmFjay5lbC5zcmMgPSB0cmFjay5vcHRpb25zLnNyY1xuXG4gICAgbGV0IGV2ZW50TmFtZXMgPSBbXG4gICAgICAnbG9hZHN0YXJ0JywgJ2xvYWRlZG1ldGFkYXRhJyxcbiAgICAgICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJyxcbiAgICAgICdwbGF5JywgJ3BhdXNlJyxcbiAgICAgICdlbmRlZCcsICd0aW1ldXBkYXRlJyxcbiAgICAgICdzZWVraW5nJywgJ3NlZWtlZCcsXG4gICAgICAnZXJyb3InLFxuICAgIF07XG5cbiAgICBldmVudE5hbWVzLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgIHRyYWNrLmVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBzdXBlci50cmlnZ2VyLmJpbmQodHJhY2ssIGV2ZW50TmFtZSwgZmFsc2UpKVxuICAgIH0pXG5cbiAgICAvLyB3ZWIgYXVkaW8gQVBJIHNldHVwIChvbmx5IG5lZWRzIHRvIGhhcHBlbiBvbmNlKVxuICAgIHRyYWNrLmRhdGEuc291cmNlID0gdHJhY2sub3B0aW9ucy5jb250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZSh0cmFjay5lbClcblxuICAgIGxldCBnYWluTm9kZSA9IHsgdHlwZTogJ0dhaW5Ob2RlJywgb3B0aW9uczogeyBnYWluOiB0cmFjay5kYXRhLmdhaW4gfSB9XG4gICAgc3VwZXIuY3JlYXRlTm9kZXMoW2dhaW5Ob2RlLCAuLi50cmFjay5vcHRpb25zLm5vZGVzXSwgdHJhY2suZGF0YS5zb3VyY2UpXG5cbiAgfVxuXG4gIHBsYXkoKXtcbiAgICB0aGlzLmVsLnBsYXkoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwYXVzZSgpe1xuICAgIHRoaXMuZWwucGF1c2UoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdG9wKCl7XG4gICAgdGhpcy5lbC5wYXVzZSgpXG4gICAgdGhpcy5lbC5jdXJyZW50VGltZSA9IDBcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY3VycmVudFRpbWUoc2V0VG8pe1xuICAgIGxldCB0cmFjayA9IHRoaXNcbiAgICBpZih0eXBlb2Ygc2V0VG8gPT09ICdudW1iZXInKXtcbiAgICAgIHRyYWNrLmVsLmN1cnJlbnRUaW1lID0gc2V0VG9cbiAgICAgIHJldHVybiB0cmFja1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhY2suZWwuY3VycmVudFRpbWVcbiAgICB9XG4gIH1cblxuICBkdXJhdGlvbigpe1xuICAgIGxldCB0cmFjayA9IHRoaXNcbiAgICByZXR1cm4gdHJhY2suZWwuZHVyYXRpb25cbiAgfVxuXG4gIGZvcm1hdHRlZFRpbWUoaW5jbHVkZUR1cmF0aW9uKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG4gICAgaWYoaW5jbHVkZUR1cmF0aW9uKVxuICAgICAgcmV0dXJuIHV0aWxzLnRpbWVGb3JtYXQodHJhY2suY3VycmVudFRpbWUoKSkgKyAnLycgKyB1dGlscy50aW1lRm9ybWF0KHRyYWNrLmR1cmF0aW9uKCkpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB1dGlscy50aW1lRm9ybWF0KHRyYWNrLmN1cnJlbnRUaW1lKCkpO1xuICB9XG5cbiAgdm9sdW1lKHNldFRvKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG4gICAgbGV0IGdhaW5Ob2RlID0gdHJhY2subm9kZSgnR2Fpbk5vZGUnKVxuXG4gICAgaWYodHlwZW9mIHNldFRvID09PSAnbnVtYmVyJykge1xuICAgICAgc2V0VG8gPSB1dGlscy5ub3JtYWxpemUoc2V0VG8pXG4gICAgICBzZXRUbyA9IHRyYWNrLm9wdGlvbnMubWl4ID8gc2V0VG8gKiB0cmFjay5vcHRpb25zLm1peC52b2x1bWUoKSA6IHNldFRvXG5cbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gc2V0IGJvdGggdGhlIGdhaW4gbm9kZSBhbmQgZWxlbWVudCB2b2x1bWUsXG4gICAgICAvLyBqdXN0IHRoZSBnYWluIG5vZGUgd2lsbCB3b3JrLCBidXQgZWxlbWVudCB2b2x1bWUgaXMgYSB1c2VmdWwgcGxhY2VcbiAgICAgIC8vIHRvIHN0b3JlIHRoZSBjdXJyZW50IHZvbHVtZSB2YWx1ZVxuXG4gICAgICBpZihnYWluTm9kZSkgZ2Fpbk5vZGUuZ2FpbihzZXRUbylcbiAgICAgIHRyYWNrLmVsLnZvbHVtZSA9IHNldFRvXG5cbiAgICAgIHJldHVybiB0cmFja1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhY2suZWwudm9sdW1lO1xuICAgIH1cblxuICB9XG5cbiAgdHdlZW5Wb2x1bWUoc2V0VG8sIGR1cmF0aW9uKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG5cbiAgICAvLyByZXBsYWNlIGV4aXN0aW5nIHZvbHVtZSB0d2VlblxuICAgIGlmKHRyYWNrLnZvbHVtZVR3ZWVuKXtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0cmFjay52b2x1bWVUd2VlbilcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcblxuICAgICAgbGV0IGZwcyA9IDYwIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgbGV0IGR1cmF0aW9uSW5GcmFtZXMgPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogZnBzKVxuICAgICAgbGV0IGZyYW1lQ291bnQgICAgICAgPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogZnBzKVxuICAgICAgbGV0IHN0YXJ0Vm9sdW1lICAgICAgPSB0cmFjay52b2x1bWUoKVxuICAgICAgbGV0IGVuZFZvbHVtZSAgICAgICAgPSB1dGlscy5ub3JtYWxpemUoc2V0VG8pXG5cbiAgICAgIHRpY2soKVxuXG4gICAgICBmdW5jdGlvbiB0aWNrKCl7XG4gICAgICAgIGlmKGZyYW1lQ291bnQgPD0gMCl7XG4gICAgICAgICAgdHJhY2sudm9sdW1lKGVuZFZvbHVtZSlcbiAgICAgICAgICByZXNvbHZlKHRyYWNrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYWNrLnZvbHVtZVR3ZWVuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKVxuICAgICAgICB9XG5cbiAgICAgICAgZnJhbWVDb3VudCAtPSAxXG4gICAgICAgIGxldCBwcm9ncmVzcyA9ICgxIC0gKGZyYW1lQ291bnQgLyBkdXJhdGlvbkluRnJhbWVzKSlcbiAgICAgICAgbGV0IHYgPSB1dGlscy5sZXJwKHN0YXJ0Vm9sdW1lLCBlbmRWb2x1bWUsIHByb2dyZXNzKVxuICAgICAgICB0cmFjay52b2x1bWUoIHYgKVxuICAgICAgfVxuXG4gICAgfSlcbiAgfVxuXG4gIG11dGVkKHNldFRvKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG4gICAgaWYodHlwZW9mIHNldFRvID09PSAnYm9vbGVhbicpe1xuICAgICAgdHJhY2suZWwubXV0ZWQgPSBzZXRUb1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2suZWwubXV0ZWRcbiAgfVxuXG4gIGRlc3Ryb3koKXtcbiAgICBsZXQgdHJhY2sgPSB0aGlzXG4gICAgdHJhY2sucGF1c2UoKVxuICB9XG5cbiAgcGF1c2VkKCl7XG4gICAgbGV0IHRyYWNrID0gdGhpc1xuICAgIHJldHVybiB0cmFjay5lbC5wYXVzZWRcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEVsZW1lbnRTb3VyY2VUcmFjayIsIi8qXG5cbiAgVHJhY2sgVHlwZXNcblxuKi9cblxuaW1wb3J0IEh0bWw1VHJhY2sgZnJvbSAnLi9IdG1sNVRyYWNrJ1xuaW1wb3J0IEJ1ZmZlclNvdXJjZVRyYWNrIGZyb20gJy4vQnVmZmVyU291cmNlVHJhY2snXG5pbXBvcnQgRWxlbWVudFNvdXJjZVRyYWNrIGZyb20gJy4vRWxlbWVudFNvdXJjZVRyYWNrJ1xuXG5leHBvcnQgZGVmYXVsdCB7IEh0bWw1VHJhY2ssIEJ1ZmZlclNvdXJjZVRyYWNrLCBFbGVtZW50U291cmNlVHJhY2sgfSIsIi8qXG5cbiAgQXVkaW8gTWl4ZXJcblxuKi9cbmltcG9ydCB0cmFja1R5cGVzIGZyb20gJy4vdHJhY2tUeXBlcydcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJ1xuXG5jbGFzcyBNaXhlciB7XG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgbGV0IG1peCA9IHRoaXNcblxuICAgIG1peC5hbGxUcmFja3MgPSBbXSAvLyB0cmFja3MgYXMgbnVtYmVyZWQgYXJyYXlcbiAgICBtaXgubG9va3VwICAgID0ge30gLy8gdHJhY2tzIGFzIGxvb2t1cCB0YWJsZTogbWl4Lmxvb2t1cFsndHJhY2tuYW1lJ11cblxuICAgIG1peC5jdXJyZW50Vm9sdW1lID0gMVxuXG4gICAgLy8gY3JlYXRlIGEgd2ViIGF1ZGlvIGNvbnRleHQ6XG4gICAgLy8gRkYsIENocm9tZSwgRWRnZSB1bnByZWZpeGVkXG4gICAgLy8gU2FmYXJpIHByZWZpeGVkXG4gICAgaWYod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KXtcbiAgICAgIHRoaXMuY29udGV4dCA9ICh0eXBlb2Ygd2luZG93LkF1ZGlvQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyB3aW5kb3cuQXVkaW9Db250ZXh0KCkgOiBuZXcgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCgpIClcbiAgICB9XG4gIH1cblxuXG4gIC8qXG5cbiAgICBDcmVhdGUgYSBuZXcgdHJhY2ssIG9yIHJldHVybiBhbiBleGlzdGluZyB0cmFja1xuXG4gICovXG4gIHRyYWNrKGlkLCBwYXJhbXMpe1xuICAgIGxldCBtaXggPSB0aGlzXG5cbiAgICBpZighaWQpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW7igJl0IGNyZWF0ZSBhIHRyYWNrIHdpdGhvdXQgYSBuYW1lJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHRyYWNrIGFscmVhZHkgZXhpc3RzLCByZXR1cm4gaXRcbiAgICBpZihtaXgubG9va3VwW2lkXSl7XG5cbiAgICAgIHJldHVybiBtaXgubG9va3VwW2lkXVxuXG4gICAgfSBlbHNlIGlmKHBhcmFtcyl7XG5cbiAgICAgIC8vIGlmIHBhcmFtcyBhcmUgcGFzc2VkLCBjcmVhdGUgYSB0cmFja1xuICAgICAgbGV0IGRlZmF1bHRzID0ge1xuICAgICAgICBpZDogICAgICAgaWQsXG4gICAgICAgIHRpbWVsaW5lOiBbXSxcbiAgICAgICAgbWl4OiAgICAgIG1peCxcbiAgICAgICAgY29udGV4dDogIG1peC5jb250ZXh0LFxuICAgICAgICB0eXBlOiAgICAgdHJhY2tUeXBlcy5IdG1sNVRyYWNrLCAvLyBkZWZhdWx0IHRvIHN0YW5kYXJkIHRyYWNrIHR5cGVcbiAgICAgIH1cbiAgICAgIGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgcGFyYW1zKVxuXG4gICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBwYXNzIHRyYWNrIHR5cGUgYXMgc3RyaW5nXG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucy50eXBlID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGlmKHRyYWNrVHlwZXNbb3B0aW9ucy50eXBlXSlcbiAgICAgICAgICBvcHRpb25zLnR5cGUgPSB0cmFja1R5cGVzW29wdGlvbnMudHlwZV1cbiAgICAgIH1cblxuICAgICAgbGV0IHRyYWNrID0gbmV3IG9wdGlvbnMudHlwZShvcHRpb25zKVxuXG4gICAgICBtaXguYWxsVHJhY2tzLnB1c2godHJhY2spO1xuICAgICAgbWl4Lmxvb2t1cFtpZF0gPSB0cmFjaztcblxuICAgICAgcmV0dXJuIHRyYWNrXG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhpcyB0cmFjayBkb2Vzbid0IGV4aXN0LCBubyBwYXJhbXMgcmVjZWl2ZWRcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICB9XG5cbiAgdHJhY2tzKCl7XG4gICAgbGV0IG1peCA9IHRoaXNcbiAgICByZXR1cm4gbWl4LmFsbFRyYWNrc1xuICB9XG5cbiAgLypcblxuICAgIFJlbW92ZSBhbiBleGlzdGluZyB0cmFjay4gQ2FuIHJlY2VpdmUgYW4gSUQgb3IgYSB0cmFjayBvYmplY3QuXG5cbiAgKi9cbiAgcmVtb3ZlKGlucHV0KXtcbiAgICBsZXQgbWl4ID0gdGhpc1xuXG4gICAgLy8gaW5wdXQgY2FuIGJlIGVpdGhlciBhIHN0cmluZyBvciBhIHRyYWNrIG9iamVjdCxcbiAgICAvLyBidXQgdGhlIHRyYWNrIG9iamVjdCBuZWVkcyB0byBoYXZlIGFuIGlkIHByb3BlcnR5XG4gICAgbGV0IHRyYWNrSWRcbiAgICBpZih0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKVxuICAgICAgdHJhY2tJZCA9IGlucHV0XG4gICAgZWxzZSBpZih0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0LmlkKVxuICAgICAgdHJhY2tJZCA9IGlucHV0LmlkXG5cbiAgICBsZXQgdHJhY2sgPSBtaXgubG9va3VwW3RyYWNrSWRdO1xuXG4gICAgZm9yICh2YXIgaSA9IG1peC5hbGxUcmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmKG1peC5hbGxUcmFja3NbaV0gPT09IHRyYWNrKXtcbiAgICAgICAgbWl4LmFsbFRyYWNrcy5zcGxpY2UoaSwgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0cmFjay5kZXN0cm95KSB0cmFjay5kZXN0cm95KClcbiAgICB0cmFjayA9IG51bGxcbiAgICBkZWxldGUgbWl4Lmxvb2t1cFt0cmFja0lkXVxuXG4gIH1cblxuXG4gIC8qXG5cbiAgICBTZXQgdGhlIG1hc3RlciB2b2x1bWUgZm9yIHRoZSBlbnRpcmUgYXVkaW8gbWl4ZXIuXG5cbiAgKi9cbiAgdm9sdW1lKHNldFRvKXtcbiAgICBsZXQgbWl4ID0gdGhpc1xuICAgIGlmKHR5cGVvZiBzZXRUbyA9PT0gJ251bWJlcicpe1xuICAgICAgbWl4LmN1cnJlbnRWb2x1bWUgPSB1dGlscy5ub3JtYWxpemUoc2V0VG8pXG5cbiAgICAgIC8vIHRyYWNrcyBtdWx0aXBseSB0aGVpciB2b2x1bWUgYnkgdGhlIG1peOKAmXMgdm9sdW1lLCBzb1xuICAgICAgLy8gd2hlbmV2ZXIgd2UgY2hhbmdlIHRoZSBtYXN0ZXIgdm9sdW1lIHdlIG5lZWQgdG8gY2FsbFxuICAgICAgLy8gdHJhY2sudm9sdW1lKCkgb25jZSB0byBnZXQgdGhlIGludGVuZGVkIHJlc3VsdFxuICAgICAgbWl4LmFsbFRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnZvbHVtZSA/IHRyYWNrLnZvbHVtZSh0cmFjay52b2x1bWUoKSkgOiAnJyApXG4gICAgfVxuICAgIHJldHVybiBtaXguY3VycmVudFZvbHVtZVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWl4ZXJcbiIsIi8qXG5cbiAgQXVkaW8gTWl4ZXJcblxuKi9cbmltcG9ydCBNaXhlciBmcm9tICcuL21vZHVsZXMvTWl4ZXInXG5pbXBvcnQgSHRtbDVUcmFjayBmcm9tICcuL21vZHVsZXMvSHRtbDVUcmFjaydcblxuZXhwb3J0IGRlZmF1bHQgeyBNaXhlciwgSHRtbDVUcmFjayB9XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')}])});